{"version":3,"sources":["webpack:///webpack/bootstrap 7009e328844d2c2bda77","webpack:///./src/Utils.ts","webpack:///./src/node/NodeUtils.ts","webpack:///./src/node/Node.ts","webpack:///./src/enums/AppendState.ts","webpack:///external \"estraverse\"","webpack:///./src/node/NodeAppender.ts","webpack:///./src/custom-nodes/AbstractCustomNode.ts","webpack:///./src/enums/NodeType.ts","webpack:///./src/node-obfuscators/AbstractNodeObfuscator.ts","webpack:///external \"format-unicorn\"","webpack:///./src/JavaScriptObfuscator.ts","webpack:///./src/node-groups/AbstractNodesGroup.ts","webpack:///./src/node-obfuscators/replacers/IdentifierReplacer.ts","webpack:///external \"escodegen\"","webpack:///./src/enums/SourceMapMode.ts","webpack:///./src/node-obfuscators/replacers/AbstractReplacer.ts","webpack:///./src/preset-options/NoCustomNodesPreset.ts","webpack:///./src/custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode.ts","webpack:///./src/enums/StringArrayEncoding.ts","webpack:///./src/node-obfuscators/replacers/StringLiteralReplacer.ts","webpack:///./src/ObfuscationResult.ts","webpack:///./src/enums/JSFuck.ts","webpack:///./src/node-obfuscators/replacers/NumberLiteralReplacer.ts","webpack:///./src/preset-options/DefaultPreset.ts","webpack:///external \"chance\"","webpack:///external \"esprima\"","webpack:///external \"path\"","webpack:///external \"babel-polyfill\"","webpack:///./src/JavaScriptObfuscatorInternal.ts","webpack:///./src/Obfuscator.ts","webpack:///./src/SourceMapCorrector.ts","webpack:///./src/StringArray.ts","webpack:///./src/cli/CLIUtils.ts","webpack:///./src/cli/JavaScriptObfuscatorCLI.ts","webpack:///./src/custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode.ts","webpack:///./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode.ts","webpack:///./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode.ts","webpack:///./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode.ts","webpack:///./src/custom-nodes/domain-lock-nodes/DomainLockNode.ts","webpack:///./src/custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode.ts","webpack:///./src/custom-nodes/string-array-nodes/StringArrayCallsWrapper.ts","webpack:///./src/custom-nodes/string-array-nodes/StringArrayNode.ts","webpack:///./src/custom-nodes/string-array-nodes/StringArrayRotateFunctionNode.ts","webpack:///./src/node-groups/ConsoleOutputNodesGroup.ts","webpack:///./src/node-groups/DebugProtectionNodesGroup.ts","webpack:///./src/node-groups/DomainLockNodesGroup.ts","webpack:///./src/node-groups/SelfDefendingNodesGroup.ts","webpack:///./src/node-groups/StringArrayNodesGroup.ts","webpack:///./src/node-obfuscators/CatchClauseObfuscator.ts","webpack:///./src/node-obfuscators/FunctionDeclarationObfuscator.ts","webpack:///./src/node-obfuscators/FunctionObfuscator.ts","webpack:///./src/node-obfuscators/LabeledStatementObfuscator.ts","webpack:///./src/node-obfuscators/LiteralObfuscator.ts","webpack:///./src/node-obfuscators/MemberExpressionObfuscator.ts","webpack:///./src/node-obfuscators/MethodDefinitionObfuscator.ts","webpack:///./src/node-obfuscators/ObjectExpressionObfuscator.ts","webpack:///./src/node-obfuscators/VariableDeclarationObfuscator.ts","webpack:///./src/node-obfuscators/replacers/BooleanLiteralReplacer.ts","webpack:///./src/options/Options.ts","webpack:///./src/options/OptionsNormalizer.ts","webpack:///./src/options/ValidationErrorsFormatter.ts","webpack:///./src/stack-trace-analyzer/StackTraceAnalyzer.ts","webpack:///./src/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor.ts","webpack:///./src/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor.ts","webpack:///./src/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor.ts","webpack:///./src/templates/custom-nodes/AtobTemplate.ts","webpack:///./src/templates/custom-nodes/Rc4Template.ts","webpack:///./src/templates/custom-nodes/SingleNodeCallControllerTemplate.ts","webpack:///./src/templates/custom-nodes/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate.ts","webpack:///./src/templates/custom-nodes/debug-protection-nodes/debug-protection-function-call-node/DebufProtectionFunctionCallTemplate.ts","webpack:///./src/templates/custom-nodes/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate.ts","webpack:///./src/templates/custom-nodes/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate.ts","webpack:///./src/templates/custom-nodes/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate.ts","webpack:///./src/templates/custom-nodes/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate.ts","webpack:///./src/templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate.ts","webpack:///./src/templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate.ts","webpack:///./src/templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate.ts","webpack:///./src/templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate.ts","webpack:///./src/templates/custom-nodes/string-array-nodes/string-array-node/StringArrayTemplate.ts","webpack:///./src/templates/custom-nodes/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate.ts","webpack:///./src/templates/custom-nodes/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate.ts","webpack:///external \"class-validator\"","webpack:///external \"commander\"","webpack:///external \"fs\"","webpack:///external \"mkdirp\"","webpack:///./index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 88);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7009e328844d2c2bda77","import { Chance } from 'chance';\n\nimport { JSFuck } from './enums/JSFuck';\n\nexport class Utils {\n    /**\n     * @type {Chance.Chance | Chance.SeededChance}\n     */\n    private static randomGenerator: Chance.Chance | Chance.SeededChance = new Chance();\n\n    /**\n     * @param array\n     * @param searchElement\n     * @returns {boolean}\n     */\n    public static arrayContains (array: any[], searchElement: any): boolean {\n        return array.indexOf(searchElement) >= 0;\n    }\n\n    /**\n     * @param array\n     * @param times\n     * @returns {T[]}\n     */\n    public static arrayRotate <T> (array: T[], times: number): T[] {\n        if (!array.length) {\n            throw new ReferenceError(`Cannot rotate empty array.`);\n        }\n\n        if (times <= 0) {\n            return array;\n        }\n\n        let newArray: T[] = array,\n            temp: T | undefined;\n\n        while (times--) {\n            temp = newArray.pop()!;\n            newArray.unshift(temp);\n        }\n\n        return newArray;\n    }\n\n    /**\n     * @param string\n     */\n    public static btoa (string: string): string {\n        const chars: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n        let output: string = '';\n\n        string = encodeURIComponent(string).replace(/%([0-9A-F]{2})/g, (match, p1) => {\n            return String.fromCharCode(parseInt('0x' + p1));\n        });\n\n        for (\n            let block: number|undefined, charCode: number, idx: number = 0, map: string = chars;\n            string.charAt(idx | 0) || (map = '=', idx % 1);\n            output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n        ) {\n            charCode = string.charCodeAt(idx += 3/4);\n\n            if (charCode > 0xFF) {\n                throw new Error(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n            }\n\n            block = block << 8 | charCode;\n        }\n\n        return output;\n    }\n\n    /**\n     * @param dec\n     * @returns {string}\n     */\n    public static decToHex (dec: number): string {\n        const radix: number = 16;\n\n        return Number(dec).toString(radix);\n    }\n\n    /**\n     * @param url\n     * @returns {string}\n     */\n    public static extractDomainFromUrl (url: string): string {\n        let domain: string;\n\n        if (url.indexOf('://') > -1 || url.indexOf('//') === 0) {\n            domain = url.split('/')[2];\n        } else {\n            domain = url.split('/')[0];\n        }\n\n        domain = domain.split(':')[0];\n\n        return domain;\n    }\n\n    /**\n     * @param min\n     * @param max\n     * @returns {number}\n     */\n    public static getRandomFloat (min: number, max: number): number {\n        return Utils.getRandomGenerator().floating({\n            min: min,\n            max: max,\n            fixed: 7\n        });\n    }\n\n    /**\n     * @returns {Chance.Chance}\n     */\n    public static getRandomGenerator (): Chance.Chance {\n        const randomGenerator: Chance.Chance = Utils.randomGenerator;\n\n        if (!randomGenerator) {\n            throw new Error(`\\`randomGenerator\\` static property is undefined`);\n        }\n\n        return Utils.randomGenerator;\n    }\n\n    /**\n     * @param min\n     * @param max\n     * @returns {number}\n     */\n    public static getRandomInteger (min: number, max: number): number {\n        return Utils.getRandomGenerator().integer({\n            min: min,\n            max: max\n        });\n    }\n\n    /**\n     * @param length\n     * @returns {string}\n     */\n    public static getRandomVariableName (length: number = 6): string {\n        const rangeMinInteger: number = 10000,\n            rangeMaxInteger: number = 99999999,\n            prefix: string = '_0x';\n\n        return `${prefix}${(\n            Utils.decToHex(\n                Utils.getRandomInteger(rangeMinInteger, rangeMaxInteger)\n            )\n        ).substr(0, length)}`;\n    }\n\n    /**\n     * @param str\n     * @param length\n     * @returns {string[]}\n     */\n    public static hideString(str: string, length: number): [string, string] {\n        const escapeRegExp: (s: string) => string = (s: string) =>\n            s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n        const randomMerge: (s1: string, s2: string) => string = function (s1: string, s2: string): string {\n            let i1: number = -1,\n                i2: number = -1,\n                result: string = '';\n\n            while (i1 < s1.length || i2 < s2.length) {\n                if (Utils.getRandomFloat(0, 1) < 0.5 && i2 < s2.length) {\n                    result += s2.charAt(++i2);\n                } else {\n                    result += s1.charAt(++i1);\n                }\n            }\n\n            return result;\n        };\n\n        const customPool: string = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n\n        let randomString: string = Utils.randomGenerator.string({length: length, pool: customPool}),\n            randomStringDiff: string = randomString.replace(\n                new RegExp('[' + escapeRegExp(str) + ']', 'g'),\n            ''),\n            randomStringDiffArray: string[] = randomStringDiff.split('');\n\n        Utils.randomGenerator.shuffle(randomStringDiffArray);\n        randomStringDiff = randomStringDiffArray.join('');\n\n        return [randomMerge(str, randomStringDiff), randomStringDiff];\n\n    }\n\n    /**\n     * @param number\n     * @returns {boolean}\n     */\n    public static isInteger (number: number): boolean {\n        return number % 1 === 0;\n    }\n\n    /**\n     * RC4 symmetric cipher encryption/decryption\n     * https://gist.github.com/farhadi/2185197\n     *\n     * @param key\n     * @param string\n     * @returns {string}\n     */\n    public static rc4 (string: string, key: string) {\n        let s: number[] = [],\n            j: number = 0,\n            x: number,\n            result: string = '';\n\n        for (var i = 0; i < 256; i++) {\n            s[i] = i;\n        }\n\n        for (i = 0; i < 256; i++) {\n            j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n        }\n\n        i = 0;\n        j = 0;\n\n        for (let y = 0; y < string.length; y++) {\n            i = (i + 1) % 256;\n            j = (j + s[i]) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n            result += String.fromCharCode(string.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n        }\n\n        return result;\n    }\n\n    /**\n     * @param randomGenerator\n     */\n    public static setRandomGenerator (randomGenerator: Chance.Chance | Chance.SeededChance): void {\n        Utils.randomGenerator = randomGenerator;\n    }\n\n    /**\n     * @param obj\n     * @returns {T}\n     */\n    public static strEnumify <T extends {[prop: string]: ''|string}> (obj: T): T {\n        return obj;\n    }\n\n    /**\n     * @param string\n     * @returns {string}\n     */\n    public static stringToJSFuck (string: string): string {\n        return Array\n            .from(string)\n            .map((character: string): string => {\n                return JSFuck[character] || character;\n            })\n            .join(' + ');\n    }\n\n    /**\n     * @param string\n     * @returns {string}\n     */\n    public static stringToUnicodeEscapeSequence (string: string): string {\n        const radix: number = 16;\n\n        let prefix: string,\n            regexp: RegExp = new RegExp('[\\x00-\\x7F]'),\n            template: string;\n\n        return `${string.replace(/[\\s\\S]/g, (escape: string): string => {\n            if (regexp.test(escape)) {\n                prefix = '\\\\x';\n                template = '0'.repeat(2);\n            } else {\n                prefix = '\\\\u';\n                template = '0'.repeat(4);\n            }\n\n            return `${prefix}${(template + escape.charCodeAt(0).toString(radix)).slice(-template.length)}`;\n        })}`;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Utils.ts","import * as escodegen from 'escodegen';\nimport * as esprima from 'esprima';\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeWithBlockStatement } from '../types/TNodeWithBlockStatement';\nimport { TStatement } from '../types/TStatement';\n\nimport { NodeType } from '../enums/NodeType';\n\nimport { Node } from './Node';\nimport { Utils } from '../Utils';\n\nexport class NodeUtils {\n    /**\n     * @type {string[]}\n     */\n    private static nodesWithBlockScope: string[] = [\n        NodeType.ArrowFunctionExpression,\n        NodeType.FunctionDeclaration,\n        NodeType.FunctionExpression,\n        NodeType.MethodDefinition,\n        NodeType.Program\n    ];\n\n    /**\n     * @param node\n     */\n    public static addXVerbatimPropertyToLiterals (node: ESTree.Node): void {\n        NodeUtils.typedReplace(node, NodeType.Literal, {\n            leave: (node: ESTree.Literal) => {\n                node['x-verbatim-property'] = {\n                    content : node.raw,\n                    precedence: escodegen.Precedence.Primary\n                };\n            }\n        });\n    }\n\n    /**\n     * @param code\n     * @returns {TStatement[]}\n     */\n    public static convertCodeToStructure (code: string): TStatement[] {\n        let structure: ESTree.Program = esprima.parse(code);\n\n        NodeUtils.addXVerbatimPropertyToLiterals(structure);\n        NodeUtils.parentize(structure);\n\n        return <TStatement[]>structure.body;\n    }\n\n    /**\n     * @param node\n     * @param index\n     * @returns {ESTree.Node}\n     */\n    public static getBlockStatementNodeByIndex (node: ESTree.Node, index: number = 0): ESTree.Node {\n        if (Node.isNodeHasBlockStatement(node)) {\n            if (node.body[index] === undefined) {\n                throw new ReferenceError(`Wrong index \\`${index}\\`. Block-statement body length is \\`${node.body.length}\\``);\n            }\n\n            return node.body[index];\n        }\n\n        throw new TypeError('The specified node have no a block-statement');\n    }\n\n    /**\n     * @param node\n     * @param depth\n     * @returns {ESTree.Node}\n     */\n    public static getBlockScopeOfNode (node: ESTree.Node, depth: number = 0): TNodeWithBlockStatement {\n        let parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (Node.isBlockStatementNode(parentNode)) {\n            if (!parentNode.parentNode) {\n                throw new ReferenceError('`parentNode` property of `parentNode` of given node is `undefined`');\n            }\n\n            if (!Utils.arrayContains(NodeUtils.nodesWithBlockScope, parentNode.parentNode.type)) {\n                return NodeUtils.getBlockScopeOfNode(parentNode, depth);\n            } else if (depth > 0) {\n                return NodeUtils.getBlockScopeOfNode(parentNode, --depth);\n            }\n\n            return parentNode;\n        }\n\n        if (Node.isProgramNode(parentNode)) {\n            return parentNode;\n        }\n\n        return NodeUtils.getBlockScopeOfNode(parentNode);\n    }\n\n    /**\n     * @param node\n     */\n    public static parentize (node: ESTree.Node): void {\n        let isRootNode: boolean = true;\n\n        estraverse.replace(node, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                let value: ESTree.Node;\n\n                if (isRootNode) {\n                    if (node.type === NodeType.Program) {\n                        value = node;\n                    } else {\n                        value = Node.getProgramNode(<TStatement[]>[node]);\n                        value.parentNode = value;\n                    }\n\n                    isRootNode = false;\n                } else {\n                    value = parentNode || node;\n                }\n\n                node.parentNode = value;\n                node.obfuscated = false;\n            }\n        });\n    }\n\n    /**\n     * @param node\n     * @param nodeType\n     * @param visitor\n     */\n    public static typedReplace (\n        node: ESTree.Node,\n        nodeType: string,\n        visitor: {enter?: (node: ESTree.Node) => void, leave?: (node: ESTree.Node) => void},\n    ): void {\n        NodeUtils.typedTraverse(node, nodeType, visitor, 'replace');\n    }\n\n    /**\n     * @param node\n     * @param nodeType\n     * @param visitor\n     * @param traverseType\n     */\n    public static typedTraverse (\n        node: ESTree.Node,\n        nodeType: string,\n        visitor: estraverse.Visitor,\n        traverseType: string = 'traverse'\n    ): void {\n        (<any>estraverse)[traverseType](node, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (node.type === nodeType && visitor.enter) {\n                    visitor.enter(node, parentNode);\n                }\n            },\n            leave: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (node.type === nodeType && visitor.leave) {\n                    visitor.leave(node, parentNode);\n                }\n            }\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node/NodeUtils.ts","import * as ESTree from 'estree';\n\nimport { TNodeWithBlockStatement } from '../types/TNodeWithBlockStatement';\nimport { TStatement } from '../types/TStatement';\n\nimport { NodeType } from '../enums/NodeType';\n\nexport class Node {\n    /**\n     * @param bodyNode\n     * @returns ESTree.Program\n     */\n    public static getProgramNode (bodyNode: TStatement[]): ESTree.Program {\n        return {\n            'type': NodeType.Program,\n            'body': bodyNode,\n            'sourceType': 'script',\n            'obfuscated': false\n        };\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isArrowFunctionExpressionNode (node: ESTree.Node): node is ESTree.ArrowFunctionExpression {\n        return node.type === NodeType.ArrowFunctionExpression;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isBlockStatementNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return node.type === NodeType.BlockStatement;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isBreakStatementNode (node: ESTree.Node): node is ESTree.BreakStatement {\n        return node.type === NodeType.BreakStatement;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isCallExpressionNode (node: ESTree.Node): node is ESTree.CallExpression {\n        return node.type === NodeType.CallExpression;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isContinueStatementNode (node: ESTree.Node): node is ESTree.ContinueStatement {\n        return node.type === NodeType.ContinueStatement;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isExpressionStatementNode (node: ESTree.Node): node is ESTree.ExpressionStatement {\n        return node.type === NodeType.ExpressionStatement;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isFunctionDeclarationNode (node: ESTree.Node): node is ESTree.FunctionDeclaration {\n        return node.type === NodeType.FunctionDeclaration;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isFunctionExpressionNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return node.type === NodeType.FunctionExpression;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isIdentifierNode (node: ESTree.Node): node is ESTree.Identifier {\n        return node.type === NodeType.Identifier;\n    }\n\n    /**\n     * @param node\n     * @param parentNode\n     * @returns {boolean}\n     */\n    public static isLabelIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        const parentNodeIsLabeledStatementNode: boolean = Node.isLabeledStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsContinueStatementNode: boolean = Node.isContinueStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsBreakStatementNode: boolean = Node.isBreakStatementNode(parentNode) && parentNode.label === node;\n\n        return parentNodeIsLabeledStatementNode ||\n            parentNodeIsContinueStatementNode ||\n            parentNodeIsBreakStatementNode;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isLabeledStatementNode (node: ESTree.Node): node is ESTree.LabeledStatement {\n        return node.type === NodeType.LabeledStatement;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isLiteralNode (node: ESTree.Node): node is ESTree.Literal {\n        return node.type === NodeType.Literal;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isMemberExpressionNode (node: ESTree.Node): node is ESTree.MemberExpression {\n        return node.type === NodeType.MemberExpression;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isObjectExpressionNode (node: ESTree.Node): node is ESTree.ObjectExpression {\n        return node.type === NodeType.ObjectExpression;\n    }\n\n    /**\n     *\n     * @param node\n     * @returns {boolean}\n     */\n    public static isProgramNode (node: ESTree.Node): node is ESTree.Program {\n        return node.type === NodeType.Program;\n    }\n\n    /**\n     *\n     * @param node\n     * @returns {boolean}\n     */\n    public static isPropertyNode (node: ESTree.Node): node is ESTree.Property {\n        return node.type === NodeType.Property;\n    }\n\n    /**\n     * @param node\n     * @param parentNode\n     * @returns {boolean}\n     */\n    public static isReplaceableIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        if (!Node.isIdentifierNode(node)) {\n            return false;\n        }\n\n        const parentNodeIsPropertyNode: boolean = Node.isPropertyNode(parentNode) && parentNode.key === node;\n        const parentNodeIsMemberExpressionNode: boolean = (\n            Node.isMemberExpressionNode(parentNode) &&\n            parentNode.computed === false &&\n            parentNode.property === node\n        );\n\n        return !parentNodeIsPropertyNode &&\n            !parentNodeIsMemberExpressionNode &&\n            !Node.isLabelIdentifierNode(node, parentNode);\n    }\n\n    /**\n     *\n     * @param node\n     * @returns {boolean}\n     */\n    public static isVariableDeclarationNode (node: ESTree.Node): node is ESTree.VariableDeclaration {\n        return node.type === NodeType.VariableDeclaration;\n    }\n\n    /**\n     *\n     * @param node\n     * @returns {boolean}\n     */\n    public static isVariableDeclaratorNode (node: ESTree.Node): node is ESTree.VariableDeclarator {\n        return node.type === NodeType.VariableDeclarator;\n    }\n\n    /**\n     * @param node\n     * @returns {boolean}\n     */\n    public static isNodeHasBlockStatement (node: ESTree.Node): node is TNodeWithBlockStatement {\n        return node.hasOwnProperty('body') && Array.isArray((<TNodeWithBlockStatement>node).body);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node/Node.ts","export enum AppendState {\n    AfterObfuscation,\n    BeforeObfuscation\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/AppendState.ts","module.exports = require(\"estraverse\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"estraverse\"\n// module id = 4\n// module chunks = 0","import * as ESTree from 'estree';\n\nimport { TNodeWithBlockStatement } from '../types/TNodeWithBlockStatement';\nimport { TStatement } from '../types/TStatement';\n\nimport { IStackTraceData } from '../interfaces/stack-trace-analyzer/IStackTraceData';\n\nimport { Utils } from '../Utils';\n\n/**\n * This class appends node into a first deepest BlockStatement in order of function calls\n *\n * For example:\n *\n * function Foo () {\n *     var baz = function () {\n *\n *     }\n *\n *     baz();\n * }\n *\n * foo();\n *\n * Appends node into block statement of `baz` function expression.\n */\nexport class NodeAppender {\n    /**\n     * @param blockScopeNode\n     * @param nodeBodyStatements\n     */\n    public static appendNode (\n        blockScopeNode: TNodeWithBlockStatement,\n        nodeBodyStatements: TStatement[]\n    ): void {\n        if (!NodeAppender.validateBodyStatements(nodeBodyStatements)) {\n            nodeBodyStatements = [];\n        }\n\n        nodeBodyStatements = NodeAppender.parentizeBodyStatementsBeforeAppend(blockScopeNode, nodeBodyStatements);\n\n        blockScopeNode.body = [\n            ...blockScopeNode.body,\n            ...nodeBodyStatements\n        ];\n    }\n\n    /**\n     * @param blockScopeStackTraceData\n     * @param blockScopeNode\n     * @param nodeBodyStatements\n     * @param index\n     */\n    public static appendNodeToOptimalBlockScope (\n        blockScopeStackTraceData: IStackTraceData[],\n        blockScopeNode: TNodeWithBlockStatement,\n        nodeBodyStatements: TStatement[],\n        index: number = 0\n    ): void {\n        let targetBlockScope: TNodeWithBlockStatement;\n\n        if (!blockScopeStackTraceData.length) {\n            targetBlockScope = blockScopeNode;\n        } else {\n            targetBlockScope = NodeAppender.getOptimalBlockScope(\n                blockScopeStackTraceData,\n                index\n            );\n        }\n\n        NodeAppender.prependNode(targetBlockScope, nodeBodyStatements);\n    }\n\n    /**\n     * Returns deepest block scope node at given deep.\n     *\n     * @param blockScopeTraceData\n     * @param index\n     * @param deep\n     * @returns {ESTree.BlockStatement}\n     */\n    public static getOptimalBlockScope (\n        blockScopeTraceData: IStackTraceData[],\n        index: number,\n        deep: number = Infinity\n    ): ESTree.BlockStatement {\n        const firstCall: IStackTraceData = blockScopeTraceData[index];\n\n        if (deep <= 0) {\n            throw new Error(`Invalid \\`deep\\` argument value. Value should be bigger then 0.`);\n        }\n\n        if (deep > 1 && firstCall.stackTrace.length) {\n            return NodeAppender.getOptimalBlockScope(firstCall.stackTrace, 0, --deep);\n        } else {\n            return firstCall.callee;\n        }\n    }\n\n    /**\n     * @param stackTraceRootLength\n     */\n    public static getRandomStackTraceIndex (stackTraceRootLength: number): number {\n        return Utils.getRandomInteger(0, Math.max(0, Math.round(stackTraceRootLength - 1)));\n    }\n\n    /**\n     * @param blockScopeNode\n     * @param nodeBodyStatements\n     * @param index\n     */\n    public static insertNodeAtIndex (\n        blockScopeNode: TNodeWithBlockStatement,\n        nodeBodyStatements: TStatement[],\n        index: number\n    ): void {\n        if (!NodeAppender.validateBodyStatements(nodeBodyStatements)) {\n            nodeBodyStatements = [];\n        }\n\n        nodeBodyStatements = NodeAppender.parentizeBodyStatementsBeforeAppend(blockScopeNode, nodeBodyStatements);\n\n        blockScopeNode.body = [\n            ...blockScopeNode.body.slice(0, index),\n            ...nodeBodyStatements,\n            ...blockScopeNode.body.slice(index)\n        ];\n    }\n\n    /**\n     * @param blockScopeNode\n     * @param nodeBodyStatements\n     */\n    public static prependNode (\n        blockScopeNode: TNodeWithBlockStatement,\n        nodeBodyStatements: TStatement[]\n    ): void {\n        if (!NodeAppender.validateBodyStatements(nodeBodyStatements)) {\n            nodeBodyStatements = [];\n        }\n\n        nodeBodyStatements = NodeAppender.parentizeBodyStatementsBeforeAppend(blockScopeNode, nodeBodyStatements);\n\n        blockScopeNode.body = [\n            ...nodeBodyStatements,\n            ...blockScopeNode.body,\n        ];\n    }\n\n    /**\n     * @param blockScopeNode\n     * @param nodeBodyStatements\n     */\n    private static parentizeBodyStatementsBeforeAppend (\n        blockScopeNode: TNodeWithBlockStatement,\n        nodeBodyStatements: TStatement[]\n    ): TStatement[] {\n        for (let statement of nodeBodyStatements) {\n            statement.parentNode = blockScopeNode;\n        }\n\n        return nodeBodyStatements;\n    }\n\n    /**\n     * @param nodeBodyStatements\n     * @returns {boolean}\n     */\n    private static validateBodyStatements (nodeBodyStatements: TStatement[]): boolean {\n        return nodeBodyStatements.every((statementNode: TStatement) => {\n            return !!statementNode && statementNode.hasOwnProperty('type');\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node/NodeAppender.ts","import * as ESTree from 'estree';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../interfaces/IOptions';\nimport { TStatement } from '../types/TStatement';\n\nimport { AppendState } from '../enums/AppendState';\n\nexport abstract class AbstractCustomNode implements ICustomNode {\n    /**\n     * @type {AppendState}\n     */\n    protected abstract appendState: AppendState;\n\n    /**\n     * @type {IOptions}\n     */\n    protected options: IOptions;\n\n    /**\n     * @param options\n     */\n    constructor (options: IOptions) {\n        this.options = options;\n    }\n\n    /**\n     * @param astTree\n     */\n    public abstract appendNode (astTree: ESTree.Node): void;\n\n    /**\n     * @returns {AppendState}\n     */\n    public getAppendState (): AppendState {\n        return this.appendState;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        return this.getNodeStructure();\n    }\n\n    /**\n     * @param appendState\n     */\n    public setAppendState (appendState: AppendState): void {\n        this.appendState = appendState;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected abstract getNodeStructure (): TStatement[];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/AbstractCustomNode.ts","import { Utils } from '../Utils';\n\nexport const NodeType: any = Utils.strEnumify({\n    ArrayExpression: 'ArrayExpression',\n    ArrowFunctionExpression: 'ArrowFunctionExpression',\n    AssignmentExpression: 'AssignmentExpression',\n    BinaryExpression: 'BinaryExpression',\n    BlockStatement: 'BlockStatement',\n    BreakStatement: 'BreakStatement',\n    CallExpression: 'CallExpression',\n    CatchClause: 'CatchClause',\n    ClassDeclaration: 'ClassDeclaration',\n    ContinueStatement: 'ContinueStatement',\n    ExpressionStatement: 'ExpressionStatement',\n    FunctionDeclaration: 'FunctionDeclaration',\n    FunctionExpression: 'FunctionExpression',\n    Identifier:  'Identifier',\n    IfStatement:  'IfStatement',\n    LabeledStatement: 'LabeledStatement',\n    Literal: 'Literal',\n    LogicalExpression: 'LogicalExpression',\n    MemberExpression: 'MemberExpression',\n    MethodDefinition: 'MethodDefinition',\n    ObjectExpression: 'ObjectExpression',\n    Program: 'Program',\n    Property: 'Property',\n    ReturnStatement: 'ReturnStatement',\n    TryStatement: 'TryStatement',\n    UnaryExpression: 'UnaryExpression',\n    UpdateExpression: 'UpdateExpression',\n    VariableDeclaration: 'VariableDeclaration',\n    VariableDeclarator: 'VariableDeclarator',\n    WhileStatement: 'WhileStatement'\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/NodeType.ts","import * as ESTree from 'estree';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { INodeObfuscator } from '../interfaces/INodeObfuscator';\nimport { IOptions } from '../interfaces/IOptions';\n\nexport abstract class AbstractNodeObfuscator implements INodeObfuscator {\n    /**\n     * @type Map <string, AbstractCustomNode>\n     */\n    protected nodes: Map <string, ICustomNode>;\n\n    /**\n     * @type {IOptions}\n     */\n    protected options: IOptions;\n\n    /**\n     * @param nodes\n     * @param options\n     */\n    constructor(nodes: Map <string, ICustomNode>, options: IOptions) {\n        this.nodes = nodes;\n        this.options = options;\n    }\n\n    /**\n     * @param node\n     * @param parentNode\n     */\n    public abstract obfuscateNode (node: ESTree.Node, parentNode?: ESTree.Node): void;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-obfuscators/AbstractNodeObfuscator.ts","module.exports = require(\"format-unicorn\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"format-unicorn\"\n// module id = 9\n// module chunks = 0","import { IObfuscationResult } from './interfaces/IObfuscationResult';\nimport { IObfuscatorOptions } from './interfaces/IObfuscatorOptions';\n\nimport { JavaScriptObfuscatorCLI } from './cli/JavaScriptObfuscatorCLI';\nimport { JavaScriptObfuscatorInternal } from './JavaScriptObfuscatorInternal';\n\nexport class JavaScriptObfuscator {\n    /**\n     * @param sourceCode\n     * @param obfuscatorOptions\n     * @returns {string}\n     */\n    public static obfuscate (sourceCode: string, obfuscatorOptions: IObfuscatorOptions = {}): IObfuscationResult {\n        let javaScriptObfuscator: JavaScriptObfuscatorInternal = new JavaScriptObfuscatorInternal(\n            sourceCode,\n            obfuscatorOptions\n        );\n\n        javaScriptObfuscator.obfuscate();\n\n        return javaScriptObfuscator.getObfuscationResult();\n    }\n\n    /**\n     * @param argv\n     */\n    public static runCLI (argv: string[]): void {\n        new JavaScriptObfuscatorCLI(argv).run();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/JavaScriptObfuscator.ts","import { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { INodesGroup } from '../interfaces/INodesGroup';\nimport { IOptions } from '../interfaces/IOptions';\nimport { IStackTraceData } from '../interfaces/stack-trace-analyzer/IStackTraceData';\n\nimport { AppendState } from '../enums/AppendState';\n\nexport abstract class AbstractNodesGroup implements INodesGroup {\n    /**\n     * @type {AppendState}\n     */\n    protected appendState: AppendState = AppendState.BeforeObfuscation;\n\n    /**\n     * @type {IStackTraceData[]}\n     */\n    protected stackTraceData: IStackTraceData[];\n\n    /**\n     * @type {IOptions}\n     */\n    protected options: IOptions;\n\n    /**\n     * @param stackTraceData\n     * @param options\n     */\n    constructor (stackTraceData: IStackTraceData[], options: IOptions) {\n        this.stackTraceData = stackTraceData;\n        this.options = options;\n    }\n\n    /**\n     * @returns {Map<string, ICustomNode> | undefined}\n     */\n    public abstract getNodes (): Map <string, ICustomNode> | undefined;\n\n    /**\n     * @param customNodes\n     * @returns {Map<string, ICustomNode>}\n     */\n    protected syncCustomNodesWithNodesGroup (customNodes: Map <string, ICustomNode>): Map <string, ICustomNode> {\n        customNodes.forEach((node: ICustomNode) => {\n            node.setAppendState(this.appendState);\n        });\n\n        return customNodes;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-groups/AbstractNodesGroup.ts","import { AbstractReplacer } from './AbstractReplacer';\nimport { Utils } from '../../Utils';\n\nexport class IdentifierReplacer extends AbstractReplacer {\n    /**\n     * @type {Map<string, string>}\n     */\n    private namesMap: Map<string, string> = new Map<string, string>();\n\n    /**\n     * @param nodeValue\n     * @returns {string}\n     */\n    public replace (nodeValue: string): string {\n        const obfuscatedIdentifierName: string|undefined = this.namesMap.get(nodeValue);\n\n        if (!obfuscatedIdentifierName) {\n            return nodeValue;\n        }\n\n        return obfuscatedIdentifierName;\n    }\n\n    /**\n     * Store all identifiers names as keys in given `namesMap` with random names as value.\n     * Reserved names will be ignored.\n     *\n     * @param nodeName\n     */\n    public storeNames (nodeName: string): void {\n        if (!this.isReservedName(nodeName)) {\n            this.namesMap.set(nodeName, Utils.getRandomVariableName());\n        }\n    }\n\n    /**\n     * @param name\n     * @returns {boolean}\n     */\n    private isReservedName (name: string): boolean {\n        return this.options.reservedNames\n            .some((reservedName: string) => {\n                return new RegExp(reservedName, 'g').test(name);\n            });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-obfuscators/replacers/IdentifierReplacer.ts","module.exports = require(\"escodegen\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"escodegen\"\n// module id = 13\n// module chunks = 0","export const SourceMapMode: any = {\n    Inline: 'inline',\n    Separate: 'separate'\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/SourceMapMode.ts","import { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/IOptions';\nimport { IReplacer } from '../../interfaces/IReplacer';\n\nexport abstract class AbstractReplacer implements IReplacer {\n    /**\n     * @type Map <string, AbstractCustomNode>\n     */\n    protected nodes: Map <string, ICustomNode>;\n\n    /**\n     * @type {IOptions}\n     */\n    protected options : IOptions;\n\n    /**\n     * @param nodes\n     * @param options\n     */\n    constructor (nodes: Map <string, ICustomNode>, options: IOptions) {\n        this.nodes = nodes;\n        this.options = options;\n    }\n\n    /**\n     * @param nodeValue\n     * @param namesMap\n     * @returns {string}\n     */\n    public abstract replace (nodeValue: any, namesMap?: Map <string, string>): string;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-obfuscators/replacers/AbstractReplacer.ts","import { IObfuscatorOptions } from '../interfaces/IObfuscatorOptions';\n\nimport { SourceMapMode } from '../enums/SourceMapMode';\n\nexport const NO_CUSTOM_NODES_PRESET: IObfuscatorOptions = Object.freeze({\n    compact: true,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    reservedNames: [],\n    rotateStringArray: false,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    stringArray: false,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0,\n    unicodeEscapeSequence: true\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/preset-options/NoCustomNodesPreset.ts","import 'format-unicorn';\n\nimport { TNodeWithBlockStatement } from '../../types/TNodeWithBlockStatement';\nimport { TStatement } from '../../types/TStatement';\n\nimport { IOptions } from '../../interfaces/IOptions';\nimport { IStackTraceData } from '../../interfaces/stack-trace-analyzer/IStackTraceData';\n\nimport { AppendState } from '../../enums/AppendState';\n\nimport { SingleNodeCallControllerTemplate } from '../../templates/custom-nodes/SingleNodeCallControllerTemplate';\n\nimport { NO_CUSTOM_NODES_PRESET } from '../../preset-options/NoCustomNodesPreset';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscator';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeUtils } from '../../node/NodeUtils';\n\nexport class NodeCallsControllerFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {AppendState}\n     */\n    protected appendState: AppendState = AppendState.BeforeObfuscation;\n\n    /**\n     * @type {string}\n     */\n    protected callsControllerFunctionName: string;\n\n    /**\n     * @type {number}\n     */\n    protected randomStackTraceIndex: number;\n\n    /**\n     * @type {IStackTraceData[]}\n     */\n    protected stackTraceData: IStackTraceData[];\n\n    /**\n     * @param stackTraceData\n     * @param callsControllerFunctionName\n     * @param randomStackTraceIndex\n     * @param options\n     */\n    constructor (\n        stackTraceData: IStackTraceData[],\n        callsControllerFunctionName: string,\n        randomStackTraceIndex: number,\n        options: IOptions\n    ) {\n        super(options);\n\n        this.stackTraceData = stackTraceData;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n        this.randomStackTraceIndex = randomStackTraceIndex;\n    }\n\n    /**\n     * @param blockScopeNode\n     */\n    public appendNode (blockScopeNode: TNodeWithBlockStatement): void {\n        let targetBlockScope: TNodeWithBlockStatement;\n\n        if (this.stackTraceData.length) {\n            targetBlockScope = NodeAppender\n                .getOptimalBlockScope(this.stackTraceData, this.randomStackTraceIndex, 1);\n        } else {\n            targetBlockScope = blockScopeNode;\n        }\n\n        NodeAppender.prependNode(targetBlockScope, this.getNode());\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        if (this.appendState === AppendState.AfterObfuscation) {\n            return NodeUtils.convertCodeToStructure(\n                JavaScriptObfuscator.obfuscate(\n                    SingleNodeCallControllerTemplate().formatUnicorn({\n                        singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n                    }),\n                    Object.assign({}, NO_CUSTOM_NODES_PRESET, {\n                        seed: this.options.seed\n                    })\n                ).getObfuscatedCode()\n            );\n        }\n\n        return NodeUtils.convertCodeToStructure(\n            SingleNodeCallControllerTemplate().formatUnicorn({\n                singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n            })\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode.ts","export const StringArrayEncoding: any = {\n    base64: 'base64',\n    rc4: 'rc4'\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/StringArrayEncoding.ts","import { TStringArrayCallsWrapper } from '../../types/custom-nodes/TStringArrayCallsWrapper';\nimport { TStringArrayNode } from '../../types/custom-nodes/TStringArrayNode';\n\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\nimport { AbstractReplacer } from './AbstractReplacer';\nimport { NumberLiteralReplacer } from './NumberLiteralReplacer';\nimport { StringArray } from '../../StringArray';\nimport { Utils } from '../../Utils';\n\nexport class StringLiteralReplacer extends AbstractReplacer {\n    /**\n     * @type {number}\n     */\n    private static minimumLengthForStringArray: number = 3;\n\n    /**\n     * @type {string[]}\n     */\n    private static rc4Keys: string[] = Utils.getRandomGenerator()\n        .n(() => Utils.getRandomGenerator().string({length: 4}), 50);\n\n    /**\n     * @param nodeValue\n     * @returns {string}\n     */\n    public replace (nodeValue: string): string {\n        const replaceWithStringArrayFlag: boolean = (\n            nodeValue.length >= StringLiteralReplacer.minimumLengthForStringArray\n            && Utils.getRandomFloat(0, 1) <= this.options.stringArrayThreshold\n        );\n\n        if (this.options.stringArray && replaceWithStringArrayFlag) {\n            return this.replaceStringLiteralWithStringArrayCall(nodeValue);\n        }\n\n        return `'${Utils.stringToUnicodeEscapeSequence(nodeValue)}'`;\n    }\n\n    /**\n     * @param value\n     * @returns {string}\n     */\n    private replaceStringLiteralWithStringArrayCall (value: string): string {\n        const stringArrayNode: TStringArrayNode = <TStringArrayNode>this.nodes.get('stringArrayNode');\n\n        if (!stringArrayNode) {\n            throw new ReferenceError('`stringArrayNode` node is not found in Map with custom node.');\n        }\n\n        let rc4Key: string = '';\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.base64:\n                value = Utils.btoa(value);\n\n                break;\n\n            case StringArrayEncoding.rc4:\n                rc4Key = Utils.getRandomGenerator().pickone(StringLiteralReplacer.rc4Keys);\n                value = Utils.btoa(Utils.rc4(value, rc4Key));\n\n                break;\n        }\n\n        if (this.options.unicodeEscapeSequence) {\n            value = Utils.stringToUnicodeEscapeSequence(value);\n        }\n\n        let stringArray: StringArray = stringArrayNode.getNodeData(),\n            indexOfExistingValue: number = stringArray.getIndexOf(value),\n            indexOfValue: number,\n            hexadecimalIndex: string;\n\n        if (indexOfExistingValue >= 0) {\n            indexOfValue = indexOfExistingValue;\n        } else {\n            indexOfValue = stringArray.getLength();\n            stringArrayNode.updateNodeData(value);\n        }\n\n        hexadecimalIndex = new NumberLiteralReplacer(this.nodes, this.options)\n            .replace(indexOfValue);\n\n        const stringArrayCallsWrapper: TStringArrayCallsWrapper = <TStringArrayCallsWrapper>this.nodes.get('stringArrayCallsWrapper');\n\n        if (!stringArrayCallsWrapper) {\n            throw new ReferenceError('`stringArrayCallsWrapper` node is not found in Map with custom node.');\n        }\n\n        if (this.options.stringArrayEncoding === StringArrayEncoding.rc4) {\n            return `${stringArrayCallsWrapper.getNodeIdentifier()}('${hexadecimalIndex}', '${Utils.stringToUnicodeEscapeSequence(rc4Key)}')`;\n        }\n\n        return `${stringArrayCallsWrapper.getNodeIdentifier()}('${hexadecimalIndex}')`;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-obfuscators/replacers/StringLiteralReplacer.ts","import { IObfuscationResult } from './interfaces/IObfuscationResult';\n\nexport class ObfuscationResult implements IObfuscationResult {\n    /**\n     * @type {string}\n     */\n    private obfuscatedCode: string;\n\n    /**\n     * @type {string}\n     */\n    private sourceMap: string;\n\n    /**\n     * @param obfuscatedCode\n     * @param sourceMap\n     */\n    constructor (obfuscatedCode: string, sourceMap: string) {\n        this.obfuscatedCode = obfuscatedCode;\n        this.sourceMap = sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getObfuscatedCode (): string {\n        return this.obfuscatedCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceMap (): string {\n        return this.sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.obfuscatedCode;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/ObfuscationResult.ts","export const JSFuck: any = {\n    False: '![]',\n    True: '!![]',\n\n    a: '(false+\"\")[1]',\n    b: '([][\"entries\"]()+\"\")[2]',\n    c: '([][\"fill\"]+\"\")[3]',\n    d: '(undefined+\"\")[2]',\n    e: '(true+\"\")[3]',\n    f: '(false+\"\")[0]',\n    g: '(false+[0]+String)[20]',\n    h: '(+(101))[\"toString\"](21)[1]',\n    i: '([false]+undefined)[10]',\n    j: '([][\"entries\"]()+\"\")[3]',\n    k: '(+(20))[\"toString\"](21)',\n    l: '(false+\"\")[2]',\n    m: '(Number+\"\")[11]',\n    n: '(undefined+\"\")[1]',\n    o: '(true+[][\"fill\"])[10]',\n    p: '(+(211))[\"toString\"](31)[1]',\n    q: '(+(212))[\"toString\"](31)[1]',\n    r: '(true+\"\")[1]',\n    s: '(false+\"\")[3]',\n    t: '(true+\"\")[0]',\n    u: '(undefined+\"\")[0]',\n    v: '(+(31))[\"toString\"](32)',\n    w: '(+(32))[\"toString\"](33)',\n    x: '(+(101))[\"toString\"](34)[1]',\n    y: '(NaN+[Infinity])[10]',\n    z: '(+(35))[\"toString\"](36)',\n\n    A: '(+[]+Array)[10]',\n    B: '(+[]+Boolean)[10]',\n    C: 'Function(\"return escape\")()((\"\")[\"italics\"]())[2]',\n    D: 'Function(\"return escape\")()([][\"fill\"])[\"slice\"](\"-1\")',\n    E: '(RegExp+\"\")[12]',\n    F: '(+[]+Function)[10]',\n    G: '(false+Function(\"return Date\")()())[30]',\n    H: `'H'`,\n    I: '(Infinity+\"\")[0]',\n    J: `'J'`,\n    K: `'K'`,\n    L: `'L'`,\n    M: '(true+Function(\"return Date\")()())[30]',\n    N: '(NaN+\"\")[0]',\n    O: '(NaN+Function(\"return{}\")())[11]',\n    P: `'P'`,\n    Q: `'Q'`,\n    R: '(+[]+RegExp)[10]',\n    S: '(+[]+String)[10]',\n    T: '(NaN+Function(\"return Date\")()())[30]',\n    U: '(NaN+Function(\"return{}\")()[\"toString\"][\"call\"]())[11]',\n    V: `'V'`,\n    W: `'W'`,\n    X: `'X'`,\n    Y: `'Y'`,\n    Z: `'Z'`\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/JSFuck.ts","import { AbstractReplacer } from './AbstractReplacer';\nimport { Utils } from '../../Utils';\n\nexport class NumberLiteralReplacer extends AbstractReplacer {\n    /**\n     * @param nodeValue\n     * @returns {string}\n     */\n    public replace (nodeValue: number): string {\n        const prefix: string = '0x';\n\n        if (!Utils.isInteger(nodeValue)) {\n            return String(nodeValue);\n        }\n\n        return `${prefix}${Utils.decToHex(nodeValue)}`;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-obfuscators/replacers/NumberLiteralReplacer.ts","import { IObfuscatorOptions } from '../interfaces/IObfuscatorOptions';\n\nimport { SourceMapMode } from '../enums/SourceMapMode';\n\nexport const DEFAULT_PRESET: IObfuscatorOptions = Object.freeze({\n    compact: true,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: true,\n    domainLock: [],\n    reservedNames: [],\n    rotateStringArray: true,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    stringArray: true,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0.8,\n    unicodeEscapeSequence: true\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/preset-options/DefaultPreset.ts","module.exports = require(\"chance\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"chance\"\n// module id = 24\n// module chunks = 0","module.exports = require(\"esprima\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"esprima\"\n// module id = 25\n// module chunks = 0","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 26\n// module chunks = 0","module.exports = require(\"babel-polyfill\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"babel-polyfill\"\n// module id = 27\n// module chunks = 0","import * as esprima from 'esprima';\nimport * as escodegen from 'escodegen';\nimport * as ESTree from 'estree';\n\nimport { Chance } from 'chance';\n\nimport { IObfuscatorOptions } from './interfaces/IObfuscatorOptions';\nimport { IGeneratorOutput } from './interfaces/IGeneratorOutput';\nimport { IObfuscationResult } from './interfaces/IObfuscationResult';\nimport { IOptions } from './interfaces/IOptions';\n\nimport { ObfuscationResult } from './ObfuscationResult';\nimport { Obfuscator } from './Obfuscator';\nimport { Options } from './options/Options';\nimport { SourceMapCorrector } from './SourceMapCorrector';\nimport { Utils } from './Utils';\n\nexport class JavaScriptObfuscatorInternal {\n    /**\n     * @type {GenerateOptions}\n     */\n    private static escodegenParams: escodegen.GenerateOptions = {\n        verbatim: 'x-verbatim-property',\n        sourceMapWithCode: true\n    };\n\n    /**\n     * @type {IGeneratorOutput}\n     */\n    private generatorOutput: IGeneratorOutput;\n\n    /**\n     * @type {IOptions}\n     */\n    private options: IOptions;\n\n    /**\n     * @type {string}\n     */\n    private sourceCode: string;\n\n    /**\n     * @param sourceCode\n     * @param obfuscatorOptions\n     */\n    constructor (sourceCode: string, obfuscatorOptions: IObfuscatorOptions = {}) {\n        this.sourceCode = sourceCode;\n        this.options = new Options(obfuscatorOptions);\n    }\n\n    /**\n     * @param sourceCode\n     * @param astTree\n     * @param options\n     */\n    private static generateCode (sourceCode: string, astTree: ESTree.Node, options: IOptions): IGeneratorOutput {\n        const escodegenParams: escodegen.GenerateOptions = Object.assign(\n            {},\n            JavaScriptObfuscatorInternal.escodegenParams\n        );\n\n        if (options.sourceMap) {\n            escodegenParams.sourceMap = 'sourceMap';\n            escodegenParams.sourceContent = sourceCode;\n        }\n\n        escodegenParams.format = {\n            compact: options.compact\n        };\n\n        const generatorOutput: IGeneratorOutput = escodegen.generate(astTree, escodegenParams);\n\n        generatorOutput.map = generatorOutput.map ? generatorOutput.map.toString() : '';\n\n        return generatorOutput;\n    }\n\n    /**\n     * @returns {IObfuscationResult}\n     */\n    public getObfuscationResult (): IObfuscationResult {\n        return new SourceMapCorrector(\n            new ObfuscationResult(\n                this.generatorOutput.code,\n                this.generatorOutput.map\n            ),\n            this.options.sourceMapBaseUrl + this.options.sourceMapFileName,\n            this.options.sourceMapMode\n        ).correct();\n    }\n\n    public obfuscate (): void {\n        let astTree: ESTree.Node = esprima.parse(this.sourceCode, {\n            loc: true\n        });\n\n        if (this.options.seed !== 0) {\n            Utils.setRandomGenerator(new Chance(this.options.seed));\n        }\n\n        astTree = new Obfuscator(this.options).obfuscateNode(astTree);\n\n        this.generatorOutput = JavaScriptObfuscatorInternal.generateCode(this.sourceCode, astTree, this.options);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/JavaScriptObfuscatorInternal.ts","import * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeGroup } from './types/TNodeGroup';\nimport { TNodeObfuscator } from './types/TNodeObfuscator';\n\nimport { ICustomNode } from './interfaces/custom-nodes/ICustomNode';\nimport { IObfuscator } from './interfaces/IObfuscator';\nimport { IOptions } from './interfaces/IOptions';\nimport { IStackTraceData } from './interfaces/stack-trace-analyzer/IStackTraceData';\n\nimport { AppendState } from './enums/AppendState';\nimport { NodeType } from './enums/NodeType';\n\nimport { CatchClauseObfuscator } from './node-obfuscators/CatchClauseObfuscator';\nimport { ConsoleOutputNodesGroup } from './node-groups/ConsoleOutputNodesGroup';\nimport { DebugProtectionNodesGroup } from './node-groups/DebugProtectionNodesGroup';\nimport { DomainLockNodesGroup } from './node-groups/DomainLockNodesGroup';\nimport { FunctionDeclarationObfuscator } from './node-obfuscators/FunctionDeclarationObfuscator';\nimport { FunctionObfuscator } from './node-obfuscators/FunctionObfuscator';\nimport { LabeledStatementObfuscator } from './node-obfuscators/LabeledStatementObfuscator';\nimport { LiteralObfuscator } from './node-obfuscators/LiteralObfuscator';\nimport { MemberExpressionObfuscator } from './node-obfuscators/MemberExpressionObfuscator';\nimport { MethodDefinitionObfuscator } from './node-obfuscators/MethodDefinitionObfuscator';\nimport { Node } from './node/Node';\nimport { NodeUtils } from './node/NodeUtils';\nimport { ObjectExpressionObfuscator } from './node-obfuscators/ObjectExpressionObfuscator';\nimport { SelfDefendingNodesGroup } from './node-groups/SelfDefendingNodesGroup';\nimport { StackTraceAnalyzer } from './stack-trace-analyzer/StackTraceAnalyzer';\nimport { StringArrayNodesGroup } from './node-groups/StringArrayNodesGroup';\nimport { VariableDeclarationObfuscator } from './node-obfuscators/VariableDeclarationObfuscator';\n\nexport class Obfuscator implements IObfuscator {\n    /**\n     * @type {TNodeGroup[]}\n     */\n    private static nodeGroups: TNodeGroup[] = [\n        DomainLockNodesGroup,\n        SelfDefendingNodesGroup,\n        ConsoleOutputNodesGroup,\n        DebugProtectionNodesGroup,\n        StringArrayNodesGroup\n    ];\n\n    /**\n     * @type {Map<string, TNodeObfuscator[]>}\n     */\n    private static nodeObfuscators: Map <string, TNodeObfuscator[]> = new Map <string, TNodeObfuscator[]> ([\n        [NodeType.ArrowFunctionExpression, [FunctionObfuscator]],\n        [NodeType.ClassDeclaration, [FunctionDeclarationObfuscator]],\n        [NodeType.CatchClause, [CatchClauseObfuscator]],\n        [NodeType.FunctionDeclaration, [\n            FunctionDeclarationObfuscator,\n            FunctionObfuscator\n        ]],\n        [NodeType.FunctionExpression, [FunctionObfuscator]],\n        [NodeType.MemberExpression, [MemberExpressionObfuscator]],\n        [NodeType.MethodDefinition, [MethodDefinitionObfuscator]],\n        [NodeType.ObjectExpression, [ObjectExpressionObfuscator]],\n        [NodeType.VariableDeclaration, [VariableDeclarationObfuscator]],\n        [NodeType.LabeledStatement, [LabeledStatementObfuscator]],\n        [NodeType.Literal, [LiteralObfuscator]]\n    ]);\n\n    /**\n     * @type {Map<string, AbstractCustomNode>}\n     */\n    private customNodes: Map <string, ICustomNode> = new Map <string, ICustomNode> ();\n\n    /**\n     * @type {IOptions}\n     */\n    private options: IOptions;\n\n    /**\n     * @param options\n     */\n    constructor (options: IOptions) {\n        this.options = options;\n    }\n\n    /**\n     * @param node\n     * @returns {ESTree.Node}\n     */\n    public obfuscateNode (node: ESTree.Program): ESTree.Node {\n        if (Node.isProgramNode(node) && !node.body.length) {\n            return node;\n        }\n\n        NodeUtils.parentize(node);\n\n        const stackTraceData: IStackTraceData[] = new StackTraceAnalyzer(node.body).analyze();\n\n        this.initializeCustomNodes(stackTraceData);\n\n        this.beforeObfuscation(node);\n        this.obfuscate(node);\n        this.afterObfuscation(node);\n\n        return node;\n    }\n\n    /**\n     * @param astTree\n     */\n    private afterObfuscation (astTree: ESTree.Node): void {\n        this.customNodes.forEach((node: ICustomNode) => {\n            if (node.getAppendState() === AppendState.AfterObfuscation) {\n                node.appendNode(astTree);\n            }\n        });\n    }\n\n    /**\n     * @param astTree\n     */\n    private beforeObfuscation (astTree: ESTree.Node): void {\n        this.customNodes.forEach((node: ICustomNode) => {\n            if (node.getAppendState() === AppendState.BeforeObfuscation) {\n                node.appendNode(astTree);\n            }\n        });\n    };\n\n    /**\n     * @param stackTraceData\n     */\n    private initializeCustomNodes (stackTraceData: IStackTraceData[]): void {\n        let customNodes: [string, ICustomNode][] = [];\n\n        Obfuscator.nodeGroups.forEach((nodeGroupConstructor: TNodeGroup) => {\n            const nodeGroupNodes: Map <string, ICustomNode> | undefined = new nodeGroupConstructor(\n                stackTraceData, this.options\n            ).getNodes();\n\n            if (!nodeGroupNodes) {\n                return;\n            }\n\n            customNodes.push(...nodeGroupNodes);\n        });\n\n        this.customNodes = new Map <string, ICustomNode> (customNodes);\n    }\n\n\n    /**\n     * @param node\n     * @param parentNode\n     */\n    private initializeNodeObfuscators (node: ESTree.Node, parentNode: ESTree.Node): void {\n        let nodeObfuscators: TNodeObfuscator[] | undefined = Obfuscator.nodeObfuscators.get(node.type);\n\n        if (!nodeObfuscators) {\n            return;\n        }\n\n        nodeObfuscators.forEach((obfuscator: TNodeObfuscator) => {\n            new obfuscator(this.customNodes, this.options).obfuscateNode(node, parentNode);\n        });\n    }\n\n    /**\n     * @param node\n     */\n    private obfuscate (node: ESTree.Node): void {\n        estraverse.traverse(node, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): void => {\n                this.initializeNodeObfuscators(node, parentNode);\n            }\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Obfuscator.ts","import { IObfuscationResult } from './interfaces/IObfuscationResult';\nimport { ISourceMapCorrector } from './interfaces/ISourceMapCorrector';\n\nimport { TSourceMapMode } from './types/TSourceMapMode';\n\nimport { SourceMapMode } from './enums/SourceMapMode';\n\nimport { ObfuscationResult } from './ObfuscationResult';\nimport { Utils } from './Utils';\n\nexport class SourceMapCorrector implements ISourceMapCorrector {\n    /**\n     * @type {string}\n     */\n    private obfuscatedCode: string;\n\n    /**\n     * @type {string}\n     */\n    private sourceMap: string;\n\n    /**\n     * @type {TSourceMapMode}\n     */\n    private sourceMapMode: TSourceMapMode;\n\n    /**\n     * @type {string}\n     */\n    private sourceMapUrl: string;\n\n    /**\n     * @param obfuscationResult\n     * @param sourceMapUrl\n     * @param sourceMapMode\n     */\n    constructor (\n        obfuscationResult: IObfuscationResult,\n        sourceMapUrl: string,\n        sourceMapMode: TSourceMapMode\n    ) {\n        this.obfuscatedCode = obfuscationResult.getObfuscatedCode();\n        this.sourceMap = obfuscationResult.getSourceMap();\n\n        this.sourceMapUrl = sourceMapUrl;\n        this.sourceMapMode = sourceMapMode;\n    }\n\n    /**\n     * @returns {ObfuscationResult}\n     */\n    public correct (): IObfuscationResult {\n        return new ObfuscationResult(\n            this.correctObfuscatedCode(),\n            this.sourceMap\n        );\n    }\n\n    /**\n     * @returns {string}\n     */\n    private correctObfuscatedCode (): string {\n        if (!this.sourceMap) {\n            return this.obfuscatedCode;\n        }\n\n        let sourceMappingUrl: string = '//# sourceMappingURL=';\n\n        switch (this.sourceMapMode) {\n            case SourceMapMode.Inline:\n                sourceMappingUrl += `data:application/json;base64,${Utils.btoa(this.sourceMap)}`;\n\n                break;\n\n            case SourceMapMode.Separate:\n            default:\n                if (!this.sourceMapUrl) {\n                    return this.obfuscatedCode;\n                }\n\n                sourceMappingUrl += this.sourceMapUrl;\n\n                break;\n        }\n\n        return `${this.obfuscatedCode}\\n${sourceMappingUrl}`;\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/SourceMapCorrector.ts","import { Utils } from './Utils';\n\nexport class StringArray {\n    /**\n     * @type {string[]}\n     */\n    private array: string[] = [];\n\n    /**\n     * @param value\n     */\n    public addToArray (value: string): void {\n        this.array.push(value);\n    }\n\n    /**\n     * @returns {string[]}\n     */\n    public getArray (): string[] {\n        return this.array;\n    }\n\n    /**\n     * @param value\n     * @returns {number}\n     */\n    public getIndexOf(value: string): number {\n        return this.array.indexOf(value);\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.array.length;\n    }\n\n    /**\n     * @param rotationValue\n     */\n    public rotateArray (rotationValue: number): void {\n        this.array = Utils.arrayRotate(this.array, rotationValue);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.array.map((value: string) => {\n            return `'${value}'`;\n        }).toString()\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/StringArray.ts","import * as fs from 'fs';\nimport * as mkdirp from 'mkdirp';\nimport * as path from 'path';\n\nimport { IPackageConfig } from '../interfaces/IPackageConfig';\n\nimport { Utils } from '../Utils';\n\nexport class CLIUtils {\n    /**\n     * @type {string[]}\n     */\n    private static availableInputExtensions: string[] = [\n        '.js'\n    ];\n\n    /**\n     * @type {BufferEncoding}\n     */\n    private static encoding: BufferEncoding = 'utf8';\n\n    /**\n     * @param outputPath\n     * @param inputPath\n     * @returns {string}\n     */\n    public static getOutputCodePath (outputPath: string, inputPath: string): string {\n        if (outputPath) {\n            return outputPath;\n        }\n\n        return inputPath\n            .split('.')\n            .map<string>((value: string, index: number) => {\n                return index === 0 ? `${value}-obfuscated` : value;\n            })\n            .join('.');\n    }\n\n    /**\n     * @param outputCodePath\n     * @param sourceMapFileName\n     * @returns {string}\n     */\n    public static getOutputSourceMapPath (outputCodePath: string, sourceMapFileName: string = ''): string {\n        if (sourceMapFileName) {\n            outputCodePath = `${outputCodePath.substr(\n                0, outputCodePath.lastIndexOf('/')\n            )}/${sourceMapFileName}`;\n        }\n\n        if (!/\\.js\\.map$/.test(outputCodePath)) {\n            outputCodePath = `${outputCodePath.split('.')[0]}.js.map`;\n        } else if (/\\.js$/.test(outputCodePath)) {\n            outputCodePath += '.map';\n        }\n\n        return outputCodePath;\n    }\n\n    /**\n     * @returns {IPackageConfig}\n     */\n    public static getPackageConfig (): IPackageConfig {\n        return <IPackageConfig>JSON.parse(\n            fs.readFileSync(\n                path.join(\n                    path.dirname(\n                        fs.realpathSync(process.argv[1])\n                    ),\n                    '../package.json'\n                ),\n                CLIUtils.encoding\n            )\n        );\n    }\n\n    /**\n     * @param filePath\n     */\n    public static isFilePath (filePath: string): boolean {\n        try {\n            return fs.statSync(filePath).isFile();\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param inputPath\n     * @returns {string}\n     */\n    public static readFile (inputPath: string): string {\n        return fs.readFileSync(inputPath, CLIUtils.encoding);\n    }\n\n    /**\n     * @param inputPath\n     */\n    public static validateInputPath (inputPath: string): void {\n        if (!CLIUtils.isFilePath(inputPath)) {\n            throw new ReferenceError(`Given input path must be a valid file path`);\n        }\n\n        if (!Utils.arrayContains(CLIUtils.availableInputExtensions, path.extname(inputPath))) {\n            throw new ReferenceError(`Input file must have .js extension`);\n        }\n    }\n\n    /**\n     * @param outputPath\n     * @param data\n     */\n    public static writeFile (outputPath: string, data: any): void {\n        mkdirp.sync(path.dirname(outputPath));\n\n        fs.writeFileSync(outputPath, data, {\n            encoding: CLIUtils.encoding\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/cli/CLIUtils.ts","import * as commander from 'commander';\nimport * as path from 'path';\n\nimport { TStringArrayEncoding } from '../types/TStringArrayEncoding';\n\nimport { IObfuscationResult } from '../interfaces/IObfuscationResult';\nimport { IObfuscatorOptions } from '../interfaces/IObfuscatorOptions';\n\nimport { SourceMapMode } from '../enums/SourceMapMode';\nimport { StringArrayEncoding } from '../enums/StringArrayEncoding';\n\nimport { DEFAULT_PRESET } from '../preset-options/DefaultPreset';\n\nimport { CLIUtils } from './CLIUtils';\nimport { JavaScriptObfuscator } from '../JavaScriptObfuscator';\nimport { Utils } from '../Utils';\n\nexport class JavaScriptObfuscatorCLI {\n    /**\n     * @type {string[]}\n     */\n    private arguments: string[];\n\n    /**\n     * @type {commander.ICommand}\n     */\n    private commands: commander.ICommand;\n\n    /**\n     * @type {string}\n     */\n    private data: string = '';\n\n    /**\n     * @type {string}\n     */\n    private inputPath: string;\n\n    /**\n     * @type {string[]}\n     */\n    private rawArguments: string[];\n\n    /**\n     * @param argv\n     */\n    constructor (argv: string[]) {\n        this.rawArguments = argv;\n        this.arguments = this.rawArguments.slice(2);\n    }\n\n    /**\n     * @returns {string}\n     */\n    private static getBuildVersion (): string {\n        return CLIUtils.getPackageConfig().version;\n    }\n\n    /**\n     * @param value\n     * @returns {boolean}\n     */\n    private static parseBoolean (value: string): boolean {\n        return value === 'true' || value === '1';\n    }\n\n    /**\n     * @param value\n     * @returns {string}\n     */\n    private static parseSourceMapMode (value: string): string {\n        let availableMode: boolean = Object\n            .keys(SourceMapMode)\n            .some((key: string): boolean => {\n                return SourceMapMode[key] === value;\n            });\n\n        if (!availableMode) {\n            throw new ReferenceError('Invalid value of `--sourceMapMode` option');\n        }\n\n        return value;\n    }\n\n    /**\n     * @param value\n     * @returns {TStringArrayEncoding}\n     */\n    private static parseStringArrayEncoding (value: string): TStringArrayEncoding {\n        switch (value) {\n            case 'true':\n            case '1':\n            case StringArrayEncoding.base64:\n                return true;\n\n            case StringArrayEncoding.rc4:\n                return StringArrayEncoding.rc4;\n\n            default:\n                return false;\n        }\n    }\n\n    public run (): void {\n        this.configureCommands();\n\n        if (!this.arguments.length || Utils.arrayContains(this.arguments, '--help')) {\n            this.commands.outputHelp();\n\n            return;\n        }\n\n        this.inputPath = this.arguments[0];\n        CLIUtils.validateInputPath(this.inputPath);\n\n        this.getData();\n        this.processData();\n    }\n\n    /**\n     * @returns {IObfuscatorOptions}\n     */\n    private buildOptions (): IObfuscatorOptions {\n        let obfuscatorOptions: IObfuscatorOptions = {},\n            availableOptions: string[] = Object.keys(DEFAULT_PRESET);\n\n        for (const option in this.commands) {\n            if (!this.commands.hasOwnProperty(option)) {\n                continue;\n            }\n\n            if (!Utils.arrayContains(availableOptions, option)) {\n                continue;\n            }\n\n            obfuscatorOptions[option] = (<any>this.commands)[option];\n        }\n\n        return Object.assign({}, DEFAULT_PRESET, obfuscatorOptions);\n    }\n\n    private configureCommands (): void {\n        this.commands = new commander.Command()\n            .version(JavaScriptObfuscatorCLI.getBuildVersion(), '-v, --version')\n            .usage('<inputPath> [options]')\n            .option('-o, --output <path>', 'Output path for obfuscated code')\n            .option('--compact <boolean>', 'Disable one line output code compacting', JavaScriptObfuscatorCLI.parseBoolean)\n            .option('--debugProtection <boolean>', 'Disable browser Debug panel (can cause DevTools enabled browser freeze)', JavaScriptObfuscatorCLI.parseBoolean)\n            .option('--debugProtectionInterval <boolean>', 'Disable browser Debug panel even after page was loaded (can cause DevTools enabled browser freeze)', JavaScriptObfuscatorCLI.parseBoolean)\n            .option('--disableConsoleOutput <boolean>', 'Allow console.log, console.info, console.error and console.warn messages output into browser console', JavaScriptObfuscatorCLI.parseBoolean)\n            .option('--domainLock <list>', 'Blocks the execution of the code in domains that do not match the passed RegExp patterns (comma separated)', (val: string) => val.split(','))\n            .option('--reservedNames <list>', 'Disable obfuscation of variable names, function names and names of function parameters that match the passed RegExp patterns (comma separated)', (val: string) => val.split(','))\n            .option('--rotateStringArray <boolean>', 'Disable rotation of unicode array values during obfuscation', JavaScriptObfuscatorCLI.parseBoolean)\n            .option('--seed <number>', 'Sets seed for random generator. This is useful for creating repeatable results.', parseFloat)\n            .option('--selfDefending <boolean>', 'Disables self-defending for obfuscated code', JavaScriptObfuscatorCLI.parseBoolean)\n            .option('--sourceMap <boolean>', 'Enables source map generation', JavaScriptObfuscatorCLI.parseBoolean)\n            .option('--sourceMapBaseUrl <string>', 'Sets base url to the source map import url when `--sourceMapMode=separate`')\n            .option('--sourceMapFileName <string>', 'Sets file name for output source map when `--sourceMapMode=separate`')\n            .option(\n                '--sourceMapMode <string> [inline, separate]',\n                'Specify source map output mode',\n                JavaScriptObfuscatorCLI.parseSourceMapMode\n            )\n            .option('--stringArray <boolean>', 'Disables gathering of all literal strings into an array and replacing every literal string with an array call', JavaScriptObfuscatorCLI.parseBoolean)\n            .option('--stringArrayEncoding <boolean|string> [true, false, base64, rc4]', 'Encodes all strings in strings array using base64 or rc4 (this option can slow down your code speed', JavaScriptObfuscatorCLI.parseStringArrayEncoding)\n            .option('--stringArrayThreshold <number>', 'The probability that the literal string will be inserted into stringArray (Default: 0.8, Min: 0, Max: 1)', parseFloat)\n            .option('--unicodeEscapeSequence <boolean>', 'Allows to enable/disable string conversion to unicode escape sequence', JavaScriptObfuscatorCLI.parseBoolean)\n            .parse(this.rawArguments);\n\n        this.commands.on('--help', () => {\n            console.log('  Examples:\\n');\n            console.log('    %> javascript-obfuscator in.js --compact true --selfDefending false');\n            console.log('    %> javascript-obfuscator in.js --output out.js --compact true --selfDefending false');\n            console.log('');\n        });\n    }\n\n    private getData (): void {\n        this.data = CLIUtils.readFile(this.inputPath);\n    }\n\n    private processData (): void {\n        let options: IObfuscatorOptions = this.buildOptions(),\n            outputCodePath: string = CLIUtils.getOutputCodePath((<any>this.commands).output, this.inputPath);\n\n        if (options.sourceMap) {\n            this.processDataWithSourceMap(outputCodePath, options);\n        } else {\n            this.processDataWithoutSourceMap(outputCodePath, options);\n        }\n    }\n\n    /**\n     * @param outputCodePath\n     * @param options\n     */\n    private processDataWithoutSourceMap (outputCodePath: string, options: IObfuscatorOptions): void {\n        let obfuscatedCode: string = JavaScriptObfuscator.obfuscate(this.data, options).getObfuscatedCode();\n\n        CLIUtils.writeFile(outputCodePath, obfuscatedCode);\n    }\n\n    /**\n     * @param outputCodePath\n     * @param options\n     */\n    private processDataWithSourceMap (outputCodePath: string, options: IObfuscatorOptions): void {\n        let outputSourceMapPath: string = CLIUtils.getOutputSourceMapPath(\n            outputCodePath,\n            options.sourceMapFileName || ''\n        );\n\n        options.sourceMapFileName = path.basename(outputSourceMapPath);\n\n        const obfuscationResult: IObfuscationResult = JavaScriptObfuscator.obfuscate(this.data, options);\n\n        CLIUtils.writeFile(outputCodePath, obfuscationResult.getObfuscatedCode());\n\n        if (options.sourceMapMode === 'separate' && obfuscationResult.getSourceMap()) {\n            CLIUtils.writeFile(outputSourceMapPath, obfuscationResult.getSourceMap());\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/cli/JavaScriptObfuscatorCLI.ts","import 'format-unicorn';\n\nimport { TNodeWithBlockStatement } from '../../types/TNodeWithBlockStatement';\nimport { TStatement } from '../../types/TStatement';\n\nimport { IOptions } from '../../interfaces/IOptions';\nimport { IStackTraceData } from '../../interfaces/stack-trace-analyzer/IStackTraceData';\n\nimport { AppendState } from '../../enums/AppendState';\n\nimport { ConsoleOutputDisableExpressionTemplate } from '../../templates/custom-nodes/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { Utils } from '../../Utils';\n\nexport class ConsoleOutputDisableExpressionNode extends AbstractCustomNode {\n    /**\n     * @type {AppendState}\n     */\n    protected appendState: AppendState = AppendState.BeforeObfuscation;\n\n    /**\n     * @type {string}\n     */\n    protected callsControllerFunctionName: string;\n\n    /**\n     * @type {number}\n     */\n    protected randomStackTraceIndex: number;\n\n    /**\n     * @type {IStackTraceData[]}\n     */\n    protected stackTraceData: IStackTraceData[];\n\n    /**\n     * @param stackTraceData\n     * @param callsControllerFunctionName\n     * @param randomStackTraceIndex\n     * @param options\n     */\n    constructor (\n        stackTraceData: IStackTraceData[],\n        callsControllerFunctionName: string,\n        randomStackTraceIndex: number,\n        options: IOptions\n    ) {\n        super(options);\n\n        this.stackTraceData = stackTraceData;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n        this.randomStackTraceIndex = randomStackTraceIndex;\n    }\n\n    /**\n     * @param blockScopeNode\n     */\n    public appendNode (blockScopeNode: TNodeWithBlockStatement): void {\n        NodeAppender.appendNodeToOptimalBlockScope(\n            this.stackTraceData,\n            blockScopeNode,\n            this.getNode(),\n            this.randomStackTraceIndex\n        );\n    }\n\n    /**\n     *  JSCrush version of following code\n     *\n     *  (function () {\n     *      var _console = [][\"filter\"][\"constructor\"](\"return this\")().console;\n     *      var _function = function () {};\n     *\n     *      _console.log = _function;\n     *      _console.info = _function;\n     *      _console.warn = _function;\n     *      _console.error = _function;\n     *  _console\n     *  })();\n     *\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(\n            ConsoleOutputDisableExpressionTemplate().formatUnicorn({\n                consoleLogDisableFunctionName: Utils.getRandomVariableName(),\n                singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n            })\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode.ts","import 'format-unicorn';\n\nimport { TNodeWithBlockStatement } from '../../types/TNodeWithBlockStatement';\nimport { TStatement } from '../../types/TStatement';\n\nimport { IOptions } from '../../interfaces/IOptions';\n\nimport { AppendState } from '../../enums/AppendState';\n\nimport { DebugProtectionFunctionCallTemplate } from '../../templates/custom-nodes/debug-protection-nodes/debug-protection-function-call-node/DebufProtectionFunctionCallTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeUtils } from '../../node/NodeUtils';\n\nexport class DebugProtectionFunctionCallNode extends AbstractCustomNode {\n    /**\n     * @type {AppendState}\n     */\n    protected appendState: AppendState = AppendState.BeforeObfuscation;\n\n    /**\n     * @type {string}\n     */\n    private debugProtectionFunctionName: string;\n\n    /**\n     * @param debugProtectionFunctionName\n     * @param options\n     */\n    constructor (debugProtectionFunctionName: string, options: IOptions) {\n        super(options);\n\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @param blockScopeNode\n     */\n    public appendNode (blockScopeNode: TNodeWithBlockStatement): void {\n        NodeAppender.appendNode(blockScopeNode, this.getNode());\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(\n            DebugProtectionFunctionCallTemplate().formatUnicorn({\n                debugProtectionFunctionName: this.debugProtectionFunctionName\n            })\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode.ts","import 'format-unicorn';\n\nimport { TNodeWithBlockStatement } from '../../types/TNodeWithBlockStatement';\nimport { TStatement } from '../../types/TStatement';\n\nimport { IOptions } from '../../interfaces/IOptions';\n\nimport { AppendState } from '../../enums/AppendState';\n\nimport { DebugProtectionFunctionIntervalTemplate } from '../../templates/custom-nodes/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeUtils } from '../../node/NodeUtils';\n\nexport class DebugProtectionFunctionIntervalNode extends AbstractCustomNode {\n    /**\n     * @type {AppendState}\n     */\n    protected appendState: AppendState = AppendState.BeforeObfuscation;\n\n    /**\n     * @type {string}\n     */\n    private debugProtectionFunctionName: string;\n\n    /**\n     * @param debugProtectionFunctionName\n     * @param options\n     */\n    constructor (debugProtectionFunctionName: string, options: IOptions) {\n        super(options);\n\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @param blockScopeNode\n     */\n    public appendNode (blockScopeNode: TNodeWithBlockStatement): void {\n        NodeAppender.appendNode(blockScopeNode, this.getNode());\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(\n            DebugProtectionFunctionIntervalTemplate().formatUnicorn({\n                debugProtectionFunctionName: this.debugProtectionFunctionName\n            })\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode.ts","import 'format-unicorn';\n\nimport { TNodeWithBlockStatement } from '../../types/TNodeWithBlockStatement';\nimport { TStatement } from '../../types/TStatement';\n\nimport { IOptions } from '../../interfaces/IOptions';\n\nimport { AppendState } from '../../enums/AppendState';\n\nimport { DebugProtectionFunctionTemplate } from '../../templates/custom-nodes/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { Utils } from '../../Utils';\n\nexport class DebugProtectionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {AppendState}\n     */\n    protected appendState: AppendState = AppendState.BeforeObfuscation;\n\n    /**\n     * @type {string}\n     */\n    private debugProtectionFunctionName: string;\n\n    /**\n     * @param debugProtectionFunctionName\n     * @param options\n     */\n    constructor (debugProtectionFunctionName: string, options: IOptions) {\n        super(options);\n\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @param blockScopeNode\n     */\n    public appendNode (blockScopeNode: TNodeWithBlockStatement): void {\n        let programBodyLength: number = blockScopeNode.body.length,\n            randomIndex: number = Utils.getRandomInteger(0, programBodyLength);\n\n        NodeAppender.insertNodeAtIndex(blockScopeNode, this.getNode(), randomIndex);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getNodeIdentifier (): string {\n        return this.debugProtectionFunctionName;\n    }\n\n    /**\n     * Found this trick in JScrambler\n     *\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(\n            DebugProtectionFunctionTemplate().formatUnicorn({\n                debugProtectionFunctionName: this.debugProtectionFunctionName\n            })\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode.ts","import 'format-unicorn';\n\nimport { TNodeWithBlockStatement } from '../../types/TNodeWithBlockStatement';\nimport { TStatement } from '../../types/TStatement';\n\nimport { IOptions } from '../../interfaces/IOptions';\nimport { IStackTraceData } from '../../interfaces/stack-trace-analyzer/IStackTraceData';\n\nimport { AppendState } from '../../enums/AppendState';\n\nimport { DomainLockNodeTemplate } from '../../templates/custom-nodes/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { Utils } from '../../Utils';\n\nexport class DomainLockNode extends AbstractCustomNode {\n    /**\n     * @type {AppendState}\n     */\n    protected appendState: AppendState = AppendState.BeforeObfuscation;\n\n    /**\n     * @type {string}\n     */\n    protected callsControllerFunctionName: string;\n\n    /**\n     * @type {number}\n     */\n    protected randomStackTraceIndex: number;\n\n    /**\n     * @type {IStackTraceData[]}\n     */\n    protected stackTraceData: IStackTraceData[];\n\n    /**\n     * @param stackTraceData\n     * @param callsControllerFunctionName\n     * @param randomStackTraceIndex\n     * @param options\n     */\n    constructor (\n        stackTraceData: IStackTraceData[],\n        callsControllerFunctionName: string,\n        randomStackTraceIndex: number,\n        options: IOptions\n    ) {\n        super(options);\n\n        this.stackTraceData = stackTraceData;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n        this.randomStackTraceIndex = randomStackTraceIndex;\n    }\n\n    /**\n     * @param blockScopeNode\n     */\n    public appendNode (blockScopeNode: TNodeWithBlockStatement): void {\n        NodeAppender.appendNodeToOptimalBlockScope(\n            this.stackTraceData,\n            blockScopeNode,\n            this.getNode(),\n            this.randomStackTraceIndex\n        );\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        let domainsString: string = this.options.domainLock.join(';'),\n            [hiddenDomainsString, diff]: string[] = Utils.hideString(domainsString, domainsString.length * 3);\n\n        return NodeUtils.convertCodeToStructure(\n            DomainLockNodeTemplate().formatUnicorn({\n                domainLockFunctionName: Utils.getRandomVariableName(),\n                diff: diff,\n                domains: hiddenDomainsString,\n                singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n            })\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/domain-lock-nodes/DomainLockNode.ts","import { TNodeWithBlockStatement } from '../../types/TNodeWithBlockStatement';\nimport { TStatement } from '../../types/TStatement';\n\nimport { IOptions } from '../../interfaces/IOptions';\nimport { IStackTraceData } from '../../interfaces/stack-trace-analyzer/IStackTraceData';\n\nimport { AppendState } from '../../enums/AppendState';\n\nimport { NO_CUSTOM_NODES_PRESET } from '../../preset-options/NoCustomNodesPreset';\n\nimport { SelfDefendingTemplate } from '../../templates/custom-nodes/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscator';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { Utils } from '../../Utils';\n\nexport class SelfDefendingUnicodeNode extends AbstractCustomNode {\n    /**\n     * @type {AppendState}\n     */\n    protected appendState: AppendState = AppendState.AfterObfuscation;\n\n    /**\n     * @type {string}\n     */\n    protected callsControllerFunctionName: string;\n\n    /**\n     * @type {number}\n     */\n    protected randomStackTraceIndex: number;\n\n    /**\n     * @type {IStackTraceData[]}\n     */\n    protected stackTraceData: IStackTraceData[];\n\n    /**\n     * @param stackTraceData\n     * @param callsControllerFunctionName\n     * @param randomStackTraceIndex\n     * @param options\n     */\n    constructor (\n        stackTraceData: IStackTraceData[],\n        callsControllerFunctionName: string,\n        randomStackTraceIndex: number,\n        options: IOptions\n    ) {\n        super(options);\n\n        this.stackTraceData = stackTraceData;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n        this.randomStackTraceIndex = randomStackTraceIndex;\n    }\n\n    /**\n     * @param blockScopeNode\n     */\n    public appendNode (blockScopeNode: TNodeWithBlockStatement): void {\n        NodeAppender.appendNodeToOptimalBlockScope(\n            this.stackTraceData,\n            blockScopeNode,\n            this.getNode(),\n            this.randomStackTraceIndex\n        );\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(\n            JavaScriptObfuscator.obfuscate(\n                SelfDefendingTemplate().formatUnicorn({\n                    selfDefendingFunctionName: Utils.getRandomVariableName(),\n                    singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n                }),\n                Object.assign({},  NO_CUSTOM_NODES_PRESET, {\n                    seed: this.options.seed\n                })\n            ).getObfuscatedCode()\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode.ts","import 'format-unicorn';\n\nimport { TNodeWithBlockStatement } from '../../types/TNodeWithBlockStatement';\nimport { TStatement } from '../../types/TStatement';\n\nimport { IOptions } from '../../interfaces/IOptions';\n\nimport { AppendState } from '../../enums/AppendState';\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\nimport { NO_CUSTOM_NODES_PRESET } from '../../preset-options/NoCustomNodesPreset';\n\nimport { AtobTemplate } from '../../templates/custom-nodes/AtobTemplate';\nimport { Rc4Template } from '../../templates/custom-nodes/Rc4Template';\nimport { SelfDefendingTemplate } from '../../templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate';\nimport { StringArrayBase64DecodeNodeTemplate } from '../../templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate';\nimport { StringArrayCallsWrapperTemplate } from '../../templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate';\nimport { StringArrayRc4DecodeNodeTemplate } from '../../templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscator';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { StringArray } from '../../StringArray';\n\nexport class StringArrayCallsWrapper extends AbstractCustomNode {\n    /**\n     * @type {AppendState}\n     */\n    protected appendState: AppendState = AppendState.AfterObfuscation;\n\n    /**\n     * @type {StringArray}\n     */\n    private stringArray: StringArray;\n\n    /**\n     * @type {string}\n     */\n    private stringArrayName: string;\n\n    /**\n     * @type {string}\n     */\n    private stringArrayCallsWrapperName: string;\n\n    /**\n     * @param stringArrayCallsWrapperName\n     * @param stringArrayName\n     * @param stringArray\n     * @param options\n     */\n    constructor (\n        stringArrayCallsWrapperName: string,\n        stringArrayName: string,\n        stringArray: StringArray,\n        options: IOptions\n    ) {\n        super(options);\n\n        this.stringArrayCallsWrapperName = stringArrayCallsWrapperName;\n        this.stringArrayName = stringArrayName;\n        this.stringArray = stringArray;\n    }\n\n    /**\n     * @param blockScopeNode\n     */\n    public appendNode (blockScopeNode: TNodeWithBlockStatement): void {\n        if (!this.stringArray.getLength()) {\n            return;\n        }\n\n        NodeAppender.insertNodeAtIndex(blockScopeNode, this.getNode(), 1);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getNodeIdentifier (): string {\n        return this.stringArrayCallsWrapperName;\n    };\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        return super.getNode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getDecodeStringArrayTemplate (): string {\n        let decodeStringArrayTemplate: string = '',\n            selfDefendingCode: string = '';\n\n        if (this.options.selfDefending) {\n            selfDefendingCode = SelfDefendingTemplate().formatUnicorn({\n                stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                stringArrayName: this.stringArrayName\n            });\n        }\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.base64:\n                decodeStringArrayTemplate = StringArrayBase64DecodeNodeTemplate().formatUnicorn({\n                    atobPolyfill: AtobTemplate(),\n                    selfDefendingCode,\n                    stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                });\n\n                break;\n\n            case StringArrayEncoding.rc4:\n                decodeStringArrayTemplate = StringArrayRc4DecodeNodeTemplate().formatUnicorn({\n                    atobPolyfill: AtobTemplate(),\n                    rc4Polyfill: Rc4Template(),\n                    selfDefendingCode,\n                    stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                });\n\n                break;\n        }\n\n        return decodeStringArrayTemplate;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const decodeNodeTemplate: string = this.getDecodeStringArrayTemplate();\n\n        return NodeUtils.convertCodeToStructure(\n            JavaScriptObfuscator.obfuscate(\n                StringArrayCallsWrapperTemplate().formatUnicorn({\n                    decodeNodeTemplate,\n                    stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                    stringArrayName: this.stringArrayName\n                }),\n                Object.assign({}, NO_CUSTOM_NODES_PRESET, {\n                    seed: this.options.seed\n                })\n            ).getObfuscatedCode()\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/string-array-nodes/StringArrayCallsWrapper.ts","import 'format-unicorn';\n\nimport { TNodeWithBlockStatement } from '../../types/TNodeWithBlockStatement';\nimport { TStatement } from '../../types/TStatement';\n\nimport { IOptions } from '../../interfaces/IOptions';\n\nimport { AppendState } from '../../enums/AppendState';\n\nimport { StringArray } from '../../StringArray';\n\nimport { StringArrayTemplate } from '../../templates/custom-nodes/string-array-nodes/string-array-node/StringArrayTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeUtils } from '../../node/NodeUtils';\n\nexport class StringArrayNode extends AbstractCustomNode {\n    /**\n     * @type {number}\n     */\n    public static ARRAY_RANDOM_LENGTH: number = 4;\n\n    /**\n     * @type {AppendState}\n     */\n    protected appendState: AppendState = AppendState.AfterObfuscation;\n\n    /**\n     * @type {StringArray}\n     */\n    private stringArray: StringArray;\n\n    /**\n     * @type {string}\n     */\n    private stringArrayName: string;\n\n    /**\n     * @type {number}\n     */\n    private stringArrayRotateValue: number;\n\n    /**\n     * @param stringArray\n     * @param stringArrayName\n     * @param stringArrayRotateValue\n     * @param options\n     */\n    constructor (\n        stringArray: StringArray,\n        stringArrayName: string,\n        stringArrayRotateValue: number = 0,\n        options: IOptions\n    ) {\n        super(options);\n\n        this.stringArray = stringArray;\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @param blockScopeNode\n     */\n    public appendNode (blockScopeNode: TNodeWithBlockStatement): void {\n        if (!this.stringArray.getLength()) {\n            return;\n        }\n\n        NodeAppender.prependNode(blockScopeNode, this.getNode());\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getNodeIdentifier (): string {\n        return this.stringArrayName;\n    }\n\n    /**\n     * @returns {StringArray}\n     */\n    public getNodeData (): StringArray {\n        return this.stringArray;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        this.stringArray.rotateArray(this.stringArrayRotateValue);\n\n        return super.getNode();\n    }\n\n    /**\n     * @param data\n     */\n    public updateNodeData (data: string): void {\n        this.stringArray.addToArray(data);\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(\n            StringArrayTemplate().formatUnicorn({\n                stringArrayName: this.stringArrayName,\n                stringArray: this.stringArray.toString()\n            })\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/string-array-nodes/StringArrayNode.ts","import 'format-unicorn';\n\nimport { TNodeWithBlockStatement } from '../../types/TNodeWithBlockStatement';\nimport { TStatement } from '../../types/TStatement';\n\nimport { IOptions } from '../../interfaces/IOptions';\n\nimport { AppendState } from '../../enums/AppendState';\n\nimport { NO_CUSTOM_NODES_PRESET } from '../../preset-options/NoCustomNodesPreset';\n\nimport { SelfDefendingTemplate } from '../../templates/custom-nodes/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate';\nimport { StringArrayRotateFunctionTemplate } from '../../templates/custom-nodes/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscator';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { StringArray } from '../../StringArray';\nimport { Utils } from '../../Utils';\n\nexport class StringArrayRotateFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {AppendState}\n     */\n    protected appendState: AppendState = AppendState.AfterObfuscation;\n\n    /**\n     * @type {StringArray}\n     */\n    private stringArray: StringArray;\n\n    /**\n     * @type {string}\n     */\n    private stringArrayName: string;\n\n    /**\n     * @param {number}\n     */\n    private stringArrayRotateValue: number;\n\n    /**\n     * @param stringArrayName\n     * @param stringArray\n     * @param stringArrayRotateValue\n     * @param options\n     */\n    constructor (\n        stringArrayName: string,\n        stringArray: StringArray,\n        stringArrayRotateValue: number,\n        options: IOptions\n    ) {\n        super(options);\n\n        this.stringArrayName = stringArrayName;\n        this.stringArray = stringArray;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @param blockScopeNode\n     */\n    public appendNode (blockScopeNode: TNodeWithBlockStatement): void {\n        if (!this.stringArray.getLength()) {\n            return;\n        }\n\n        NodeAppender.insertNodeAtIndex(blockScopeNode, this.getNode(), 1);\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        return super.getNode();\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        let code: string = '',\n            timesName: string = Utils.getRandomVariableName(),\n            whileFunctionName: string = Utils.getRandomVariableName();\n\n        if (this.options.selfDefending) {\n            code = SelfDefendingTemplate().formatUnicorn({\n                timesName,\n                whileFunctionName\n            });\n        } else {\n            code = `${whileFunctionName}(++${timesName})`;\n        }\n\n        return NodeUtils.convertCodeToStructure(\n            JavaScriptObfuscator.obfuscate(\n                StringArrayRotateFunctionTemplate().formatUnicorn({\n                    code,\n                    timesName,\n                    stringArrayName: this.stringArrayName,\n                    stringArrayRotateValue: Utils.decToHex(this.stringArrayRotateValue),\n                    whileFunctionName\n                }),\n                Object.assign({}, NO_CUSTOM_NODES_PRESET, {\n                    seed: this.options.seed\n                })\n            ).getObfuscatedCode()\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/string-array-nodes/StringArrayRotateFunctionNode.ts","import { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\n\nimport { ConsoleOutputDisableExpressionNode } from '../custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode';\nimport { NodeCallsControllerFunctionNode } from '../custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode';\n\nimport { AbstractNodesGroup } from './AbstractNodesGroup';\nimport { NodeAppender } from '../node/NodeAppender';\nimport { Utils } from '../Utils';\n\nexport class ConsoleOutputNodesGroup extends AbstractNodesGroup {\n    /**\n     * @returns {Map<string, ICustomNode>}\n     */\n    public getNodes (): Map <string, ICustomNode> | undefined {\n        if (!this.options.disableConsoleOutput) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = Utils.getRandomVariableName();\n        const randomStackTraceIndex: number = NodeAppender.getRandomStackTraceIndex(this.stackTraceData.length);\n\n        return this.syncCustomNodesWithNodesGroup(new Map <string, ICustomNode> ([\n            [\n                'consoleOutputDisableExpressionNode',\n                new ConsoleOutputDisableExpressionNode(\n                    this.stackTraceData,\n                    callsControllerFunctionName,\n                    randomStackTraceIndex,\n                    this.options\n                )\n            ],\n            [\n                'ConsoleOutputNodeCallsControllerFunctionNode',\n                new NodeCallsControllerFunctionNode(\n                    this.stackTraceData,\n                    callsControllerFunctionName,\n                    randomStackTraceIndex,\n                    this.options\n                )\n            ]\n        ]));\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-groups/ConsoleOutputNodesGroup.ts","import { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\n\nimport { DebugProtectionFunctionCallNode } from '../custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode';\nimport { DebugProtectionFunctionIntervalNode } from '../custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode';\nimport { DebugProtectionFunctionNode } from '../custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode';\n\nimport { AbstractNodesGroup } from './AbstractNodesGroup';\nimport { Utils } from '../Utils';\n\nexport class DebugProtectionNodesGroup extends AbstractNodesGroup {\n    /**\n     * @returns {Map<string, ICustomNode> | undefined}\n     */\n    public getNodes (): Map <string, ICustomNode> | undefined {\n        if (!this.options.debugProtection) {\n            return;\n        }\n\n        const debugProtectionFunctionName: string = Utils.getRandomVariableName();\n        const customNodes: Map <string, ICustomNode> = new Map <string, ICustomNode> ([\n            [\n                'debugProtectionFunctionNode',\n                new DebugProtectionFunctionNode(debugProtectionFunctionName, this.options)\n            ],\n            [\n                'debugProtectionFunctionCallNode',\n                new DebugProtectionFunctionCallNode(debugProtectionFunctionName, this.options)\n            ]\n        ]);\n\n        if (this.options.debugProtectionInterval) {\n            customNodes.set(\n                'debugProtectionFunctionIntervalNode',\n                new DebugProtectionFunctionIntervalNode(debugProtectionFunctionName, this.options)\n            );\n        }\n\n        return this.syncCustomNodesWithNodesGroup(customNodes);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-groups/DebugProtectionNodesGroup.ts","import { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\n\nimport { DomainLockNode } from '../custom-nodes/domain-lock-nodes/DomainLockNode';\nimport { NodeCallsControllerFunctionNode } from '../custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode';\n\nimport { AbstractNodesGroup } from './AbstractNodesGroup';\nimport { NodeAppender } from '../node/NodeAppender';\nimport { Utils } from '../Utils';\n\nexport class DomainLockNodesGroup extends AbstractNodesGroup {\n    /**\n     * @returns {Map<string, ICustomNode> | undefined}\n     */\n    public getNodes (): Map <string, ICustomNode> | undefined {\n        if (!this.options.domainLock.length) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = Utils.getRandomVariableName();\n        const randomStackTraceIndex: number = NodeAppender.getRandomStackTraceIndex(this.stackTraceData.length);\n\n        return this.syncCustomNodesWithNodesGroup(new Map <string, ICustomNode> ([\n            [\n                'DomainLockNode',\n                new DomainLockNode(\n                    this.stackTraceData,\n                    callsControllerFunctionName,\n                    randomStackTraceIndex,\n                    this.options\n                )\n            ],\n            [\n                'DomainLockNodeCallsControllerFunctionNode',\n                new NodeCallsControllerFunctionNode(\n                    this.stackTraceData,\n                    callsControllerFunctionName,\n                    randomStackTraceIndex,\n                    this.options\n                )\n            ]\n        ]));\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-groups/DomainLockNodesGroup.ts","import { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\n\nimport { AppendState } from '../enums/AppendState';\n\nimport { NodeCallsControllerFunctionNode } from '../custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode';\nimport { SelfDefendingUnicodeNode } from '../custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode';\n\nimport { AbstractNodesGroup } from './AbstractNodesGroup';\nimport { NodeAppender } from '../node/NodeAppender';\nimport { Utils } from '../Utils';\n\nexport class SelfDefendingNodesGroup extends AbstractNodesGroup {\n    /**\n     * @type {AppendState}\n     */\n    protected appendState: AppendState = AppendState.AfterObfuscation;\n\n    /**\n     * @returns {Map<string, ICustomNode> | undefined}\n     */\n    public getNodes (): Map <string, ICustomNode> | undefined {\n        if (!this.options.selfDefending) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = Utils.getRandomVariableName();\n        const randomStackTraceIndex: number = NodeAppender.getRandomStackTraceIndex(this.stackTraceData.length);\n\n        return this.syncCustomNodesWithNodesGroup(new Map <string, ICustomNode> ([\n            [\n                'selfDefendingUnicodeNode',\n                new SelfDefendingUnicodeNode(\n                    this.stackTraceData,\n                    callsControllerFunctionName,\n                    randomStackTraceIndex,\n                    this.options\n                )\n            ],\n            [\n                'SelfDefendingNodeCallsControllerFunctionNode',\n                new NodeCallsControllerFunctionNode(\n                    this.stackTraceData,\n                    callsControllerFunctionName,\n                    randomStackTraceIndex,\n                    this.options\n                )\n            ]\n        ]));\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-groups/SelfDefendingNodesGroup.ts","import { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\n\nimport { AppendState } from '../enums/AppendState';\n\nimport { StringArrayCallsWrapper } from '../custom-nodes/string-array-nodes/StringArrayCallsWrapper';\nimport { StringArrayNode } from '../custom-nodes/string-array-nodes/StringArrayNode';\nimport { StringArrayRotateFunctionNode } from '../custom-nodes/string-array-nodes/StringArrayRotateFunctionNode';\n\nimport { AbstractNodesGroup } from './AbstractNodesGroup';\nimport { StringArray } from '../StringArray';\nimport { Utils } from '../Utils';\n\nexport class StringArrayNodesGroup extends AbstractNodesGroup {\n    /**\n     * @type {AppendState}\n     */\n    protected appendState: AppendState = AppendState.AfterObfuscation;\n\n    /**\n     * @type {string}\n     */\n    private stringArrayName: string = Utils.getRandomVariableName(StringArrayNode.ARRAY_RANDOM_LENGTH);\n\n    /**\n     * @type {string}\n     */\n    private stringArrayCallsWrapper: string = Utils.getRandomVariableName(StringArrayNode.ARRAY_RANDOM_LENGTH);\n\n    /**\n     * @type {number}\n     */\n    private stringArrayRotateValue: number;\n\n    /**\n     * @returns {Map<string, ICustomNode> | undefined}\n     */\n    public getNodes (): Map <string, ICustomNode> | undefined {\n        if (!this.options.stringArray) {\n            return;\n        }\n\n        if (this.options.rotateStringArray) {\n            this.stringArrayRotateValue = Utils.getRandomInteger(100, 500);\n        } else {\n            this.stringArrayRotateValue = 0;\n        }\n\n        const stringArray: StringArray = new StringArray();\n        const stringArrayNode: ICustomNode = new StringArrayNode(\n            stringArray,\n            this.stringArrayName,\n            this.stringArrayRotateValue,\n            this.options\n        );\n        const customNodes: Map <string, ICustomNode> = new Map <string, ICustomNode> ([\n            [\n                'stringArrayNode', stringArrayNode,\n            ],\n            [\n                'stringArrayCallsWrapper',\n                new StringArrayCallsWrapper(\n                    this.stringArrayCallsWrapper,\n                    this.stringArrayName,\n                    stringArray,\n                    this.options\n                )\n            ]\n        ]);\n\n        if (this.options.rotateStringArray) {\n            customNodes.set(\n                'stringArrayRotateFunctionNode',\n                new StringArrayRotateFunctionNode(\n                    this.stringArrayName,\n                    stringArray,\n                    this.stringArrayRotateValue,\n                    this.options\n                )\n            );\n        }\n\n        return this.syncCustomNodesWithNodesGroup(customNodes);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-groups/StringArrayNodesGroup.ts","import * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../interfaces/IOptions';\n\nimport { NodeType } from '../enums/NodeType';\n\nimport { AbstractNodeObfuscator } from './AbstractNodeObfuscator';\nimport { IdentifierReplacer } from './replacers/IdentifierReplacer';\nimport { Node } from '../node/Node';\nimport { NodeUtils } from '../node/NodeUtils';\n\n/**\n * replaces:\n *     try {} catch (e) { console.log(e); };\n *\n * on:\n *     try {} catch (_0x12d45f) { console.log(_0x12d45f); };\n *\n */\nexport class CatchClauseObfuscator extends AbstractNodeObfuscator {\n    /**\n     * @type {IdentifierReplacer}\n     */\n    private identifierReplacer: IdentifierReplacer;\n\n    /**\n     * @param nodes\n     * @param options\n     */\n    constructor(nodes: Map <string, ICustomNode>, options: IOptions) {\n        super(nodes, options);\n\n        this.identifierReplacer = new IdentifierReplacer(this.nodes, this.options);\n    }\n\n    /**\n     * @param catchClauseNode\n     */\n    public obfuscateNode (catchClauseNode: ESTree.CatchClause): void {\n        this.storeCatchClauseParam(catchClauseNode);\n        this.replaceCatchClauseParam(catchClauseNode);\n    }\n\n    /**\n     * @param catchClauseNode\n     */\n    private storeCatchClauseParam (catchClauseNode: ESTree.CatchClause): void {\n        if (Node.isIdentifierNode(catchClauseNode.param)) {\n            this.identifierReplacer.storeNames(catchClauseNode.param.name);\n        }\n    }\n\n    /**\n     * @param catchClauseNode\n     */\n    private replaceCatchClauseParam (catchClauseNode: ESTree.CatchClause): void {\n        estraverse.replace(catchClauseNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (Node.isReplaceableIdentifierNode(node, parentNode)) {\n                    const newNodeName: string = this.identifierReplacer.replace(node.name);\n\n                    if (node.name !== newNodeName) {\n                        node.name = newNodeName;\n                        node.obfuscated = true;\n                    }\n                }\n            }\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-obfuscators/CatchClauseObfuscator.ts","import * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeWithBlockStatement } from '../types/TNodeWithBlockStatement';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../interfaces/IOptions';\n\nimport { NodeType } from '../enums/NodeType';\n\nimport { AbstractNodeObfuscator } from './AbstractNodeObfuscator';\nimport { IdentifierReplacer } from './replacers/IdentifierReplacer';\nimport { Node } from '../node/Node';\nimport { NodeUtils } from '../node/NodeUtils';\n\n/**\n * replaces:\n *     function foo () { //... };\n *     foo();\n *\n * on:\n *     function _0x12d45f () { //... };\n *     _0x12d45f();\n */\nexport class FunctionDeclarationObfuscator extends AbstractNodeObfuscator {\n    /**\n     * @type {IdentifierReplacer}\n     */\n    private identifierReplacer: IdentifierReplacer;\n\n    /**\n     * @param nodes\n     * @param options\n     */\n    constructor(nodes: Map <string, ICustomNode>, options: IOptions) {\n        super(nodes, options);\n\n        this.identifierReplacer = new IdentifierReplacer(this.nodes, this.options);\n    }\n\n    /**\n     * @param functionDeclarationNode\n     * @param parentNode\n     */\n    public obfuscateNode (functionDeclarationNode: ESTree.FunctionDeclaration, parentNode: ESTree.Node): void {\n        const blockScopeOfFunctionDeclarationNode: TNodeWithBlockStatement = NodeUtils\n            .getBlockScopeOfNode(functionDeclarationNode);\n\n        if (blockScopeOfFunctionDeclarationNode.type === NodeType.Program) {\n            return;\n        }\n\n        this.storeFunctionName(functionDeclarationNode);\n        this.replaceFunctionName(blockScopeOfFunctionDeclarationNode);\n    }\n\n    /**\n     * @param functionDeclarationNode\n     */\n    private storeFunctionName (functionDeclarationNode: ESTree.FunctionDeclaration): void {\n        NodeUtils.typedReplace(functionDeclarationNode.id, NodeType.Identifier, {\n            enter: (node: ESTree.Identifier) => this.identifierReplacer.storeNames(node.name)\n        });\n    }\n\n    /**\n     * @param scopeNode\n     */\n    private replaceFunctionName (scopeNode: ESTree.Node): void {\n        estraverse.replace(scopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (Node.isReplaceableIdentifierNode(node, parentNode)) {\n                    node.name = this.identifierReplacer.replace(node.name);\n                }\n            }\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-obfuscators/FunctionDeclarationObfuscator.ts","import * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../interfaces/IOptions';\n\nimport { AbstractNodeObfuscator } from './AbstractNodeObfuscator';\nimport { IdentifierReplacer } from './replacers/IdentifierReplacer';\nimport { Node } from '../node/Node';\n\n/**\n * replaces:\n *     function foo (argument1) { return argument1; };\n *\n * on:\n *     function foo (_0x12d45f) { return _0x12d45f; };\n *\n */\nexport class FunctionObfuscator extends AbstractNodeObfuscator {\n    /**\n     * @type {IdentifierReplacer}\n     */\n    private identifierReplacer: IdentifierReplacer;\n\n    /**\n     * @param nodes\n     * @param options\n     */\n    constructor(nodes: Map <string, ICustomNode>, options: IOptions) {\n        super(nodes, options);\n\n        this.identifierReplacer = new IdentifierReplacer(this.nodes, this.options);\n    }\n\n    /**\n     * @param functionNode\n     */\n    public obfuscateNode (functionNode: ESTree.Function): void {\n        this.storeFunctionParams(functionNode);\n        this.replaceFunctionParams(functionNode);\n    }\n\n    /**\n     * @param functionNode\n     */\n    private storeFunctionParams (functionNode: ESTree.Function): void {\n        functionNode.params\n            .forEach((paramsNode: ESTree.Node) => {\n                if (Node.isIdentifierNode(paramsNode)) {\n                    this.identifierReplacer.storeNames(paramsNode.name);\n                }\n            });\n    }\n\n    /**\n     * @param functionNode\n     */\n    private replaceFunctionParams (functionNode: ESTree.Function): void {\n        let replaceVisitor: estraverse.Visitor = {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (Node.isReplaceableIdentifierNode(node, parentNode)) {\n                    const newNodeName: string = this.identifierReplacer.replace(node.name);\n\n                    if (node.name !== newNodeName) {\n                        node.name = newNodeName;\n                        node.obfuscated = true;\n                    }\n                }\n            }\n        };\n\n        functionNode.params\n            .forEach((paramsNode: ESTree.Node) => {\n                estraverse.replace(paramsNode, replaceVisitor);\n            });\n\n        estraverse.replace(functionNode.body, replaceVisitor);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-obfuscators/FunctionObfuscator.ts","import * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../interfaces/IOptions';\n\nimport { NodeType } from '../enums/NodeType';\n\nimport { AbstractNodeObfuscator } from './AbstractNodeObfuscator';\nimport { IdentifierReplacer } from './replacers/IdentifierReplacer';\nimport { Node } from '../node/Node';\nimport { NodeUtils } from '../node/NodeUtils';\n\n/**\n * replaces:\n *     label: {\n *          for (var i = 0; i < 1000; i++) {\n *              break label;\n *          }\n *     }\n *\n * on:\n *     _0x12d45f: {\n *          for (var i = 0; i < 1000; i++) {\n *              break _0x12d45f;\n *          }\n *     }\n *\n */\nexport class LabeledStatementObfuscator extends AbstractNodeObfuscator {\n    /**\n     * @type {IdentifierReplacer}\n     */\n    private identifierReplacer: IdentifierReplacer;\n\n    /**\n     * @param nodes\n     * @param options\n     */\n    constructor(nodes: Map <string, ICustomNode>, options: IOptions) {\n        super(nodes, options);\n\n        this.identifierReplacer = new IdentifierReplacer(this.nodes, this.options);\n    }\n\n    /**\n     * @param labeledStatementNode\n     */\n    public obfuscateNode (labeledStatementNode: ESTree.LabeledStatement): void {\n        this.storeLabeledStatementName(labeledStatementNode);\n        this.replaceLabeledStatementName(labeledStatementNode);\n    }\n\n    /**\n     * @param labeledStatementNode\n     */\n    private storeLabeledStatementName (labeledStatementNode: ESTree.LabeledStatement): void {\n        NodeUtils.typedReplace(labeledStatementNode.label, NodeType.Identifier, {\n            enter: (node: ESTree.Identifier) => this.identifierReplacer.storeNames(node.name)\n        });\n    }\n\n    /**\n     * @param labeledStatementNode\n     */\n    private replaceLabeledStatementName (labeledStatementNode: ESTree.LabeledStatement): void {\n        estraverse.replace(labeledStatementNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (Node.isLabelIdentifierNode(node, parentNode)) {\n                    node.name = this.identifierReplacer.replace(node.name);\n                }\n            }\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-obfuscators/LabeledStatementObfuscator.ts","import * as escodegen from 'escodegen';\nimport * as ESTree from 'estree';\n\nimport { AbstractNodeObfuscator } from './AbstractNodeObfuscator';\nimport { BooleanLiteralReplacer } from './replacers/BooleanLiteralReplacer';\nimport { Node } from '../node/Node';\nimport { NumberLiteralReplacer } from './replacers/NumberLiteralReplacer';\nimport { StringLiteralReplacer } from './replacers/StringLiteralReplacer';\n\nexport class LiteralObfuscator extends AbstractNodeObfuscator {\n    /**\n     * @param literalNode\n     * @param parentNode\n     */\n    public obfuscateNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): void {\n        if (Node.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return;\n        }\n\n        let content: string;\n\n        switch (typeof literalNode.value) {\n            case 'boolean':\n                content = new BooleanLiteralReplacer(this.nodes, this.options)\n                    .replace(<boolean>literalNode.value);\n\n                break;\n\n            case 'number':\n                content = new NumberLiteralReplacer(this.nodes, this.options)\n                    .replace(<number>literalNode.value);\n\n                break;\n\n            case 'string':\n                content = new StringLiteralReplacer(this.nodes, this.options)\n                        .replace(<string>literalNode.value);\n\n                break;\n\n            default:\n                return;\n        }\n\n        literalNode['x-verbatim-property'] = {\n            content : content,\n            precedence: escodegen.Precedence.Primary\n        };\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-obfuscators/LiteralObfuscator.ts","import * as escodegen from 'escodegen';\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { NodeType } from '../enums/NodeType';\n\nimport { AbstractNodeObfuscator } from './AbstractNodeObfuscator';\nimport { Node } from '../node/Node';\nimport { StringLiteralReplacer } from './replacers/StringLiteralReplacer';\n\nexport class MemberExpressionObfuscator extends AbstractNodeObfuscator {\n    /**\n     * @param memberExpressionNode\n     */\n    public obfuscateNode (memberExpressionNode: ESTree.MemberExpression): void {\n        estraverse.replace(memberExpressionNode.property, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (Node.isLiteralNode(node)) {\n                    this.obfuscateLiteralProperty(node);\n\n                    return;\n                }\n\n                if (Node.isIdentifierNode(node)) {\n                    if (memberExpressionNode.computed) {\n                        return;\n                    }\n\n                    memberExpressionNode.computed = true;\n                    this.obfuscateIdentifierProperty(node);\n                }\n            }\n        });\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object[_0x23d45[25]] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     *\n     * @param node\n     */\n    private obfuscateIdentifierProperty (node: ESTree.Identifier): void {\n        let nodeValue: string = node.name,\n            literalNode: ESTree.Literal = {\n                raw: `'${nodeValue}'`,\n                'x-verbatim-property': {\n                    content : new StringLiteralReplacer(this.nodes, this.options).replace(nodeValue),\n                    precedence: escodegen.Precedence.Primary\n                },\n                type: NodeType.Literal,\n                value: nodeValue\n            };\n\n        delete node.name;\n\n        Object.assign(node, literalNode);\n    }\n\n    /**\n     * replaces:\n     *     object['literal'] = 1;\n     *\n     * on:\n     *     object[_0x23d45[25]] = 1;\n     *\n     * @param node\n     */\n    private obfuscateLiteralProperty (node: ESTree.Literal): void {\n        if (typeof node.value === 'string' && !node['x-verbatim-property']) {\n            node['x-verbatim-property'] = {\n                content : new StringLiteralReplacer(this.nodes, this.options).replace(node.value),\n                precedence: escodegen.Precedence.Primary\n            };\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-obfuscators/MemberExpressionObfuscator.ts","import * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { AbstractNodeObfuscator } from './AbstractNodeObfuscator';\nimport { Node } from '../node/Node';\nimport { Utils } from '../Utils';\nimport { StringLiteralReplacer } from './replacers/StringLiteralReplacer';\n\n/**\n * replaces:\n *     foo () { //... };\n *\n * on:\n *     [_0x9a4e('0x0')] { //... };\n */\nexport class MethodDefinitionObfuscator extends AbstractNodeObfuscator {\n    /**\n     * @type {string[]}\n     */\n    private static ignoredNames: string[] = ['constructor'];\n\n    /**\n     * @param methodDefinitionNode\n     * @param parentNode\n     */\n    public obfuscateNode (methodDefinitionNode: ESTree.MethodDefinition, parentNode: ESTree.Node): void {\n        this.replaceMethodName(methodDefinitionNode);\n    }\n\n    /**\n     * @param methodDefinitionNode\n     */\n    private replaceMethodName (methodDefinitionNode: ESTree.MethodDefinition): void {\n        estraverse.replace(methodDefinitionNode.key, {\n            enter: (node: ESTree.Node): any => {\n                if (\n                    Node.isIdentifierNode(node) &&\n                    !Utils.arrayContains(MethodDefinitionObfuscator.ignoredNames, node.name) &&\n                    methodDefinitionNode.computed === false\n                ) {\n                    methodDefinitionNode.computed = true;\n                    node.name = new StringLiteralReplacer(this.nodes, this.options)\n                        .replace(node.name);\n\n                    return;\n                }\n\n                return estraverse.VisitorOption.Skip;\n            }\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-obfuscators/MethodDefinitionObfuscator.ts","import * as escodegen from 'escodegen';\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { NodeType } from '../enums/NodeType';\n\nimport { AbstractNodeObfuscator } from './AbstractNodeObfuscator';\nimport { Node } from '../node/Node';\nimport { Utils } from '../Utils';\n\n/**\n * replaces:\n *     var object = { 'PSEUDO': 1 };\n *\n * or:\n *     var object = { PSEUDO: 1 };\n *\n * on:\n *     var object = { '\\u0050\\u0053\\u0045\\u0055\\u0044\\u004f': 1 };\n */\nexport class ObjectExpressionObfuscator extends AbstractNodeObfuscator {\n    /**\n     * @param objectExpressionNode\n     */\n    public obfuscateNode (objectExpressionNode: ESTree.ObjectExpression): void {\n        objectExpressionNode.properties\n            .forEach((property: ESTree.Property) => {\n                if (property.shorthand) {\n                    property.shorthand = false;\n                }\n\n                estraverse.replace(property.key, {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                        if (Node.isLiteralNode(node)) {\n                            this.obfuscateLiteralPropertyKey(node);\n\n                            return;\n                        }\n\n                        if (Node.isIdentifierNode(node)) {\n                            this.obfuscateIdentifierPropertyKey(node);\n                        }\n                    }\n                });\n            });\n    }\n\n    /**\n     * @param node\n     */\n    private obfuscateLiteralPropertyKey (node: ESTree.Literal): void {\n        if (typeof node.value === 'string' && !node['x-verbatim-property']) {\n            node['x-verbatim-property'] = {\n                content : `'${Utils.stringToUnicodeEscapeSequence(node.value)}'`,\n                precedence: escodegen.Precedence.Primary\n            };\n        }\n    }\n\n    /**\n     * @param node\n     */\n    private obfuscateIdentifierPropertyKey (node: ESTree.Identifier): void {\n        let nodeValue: string = node.name,\n            literalNode: ESTree.Literal = {\n                raw: `'${nodeValue}'`,\n                'x-verbatim-property': {\n                    content : `'${Utils.stringToUnicodeEscapeSequence(nodeValue)}'`,\n                    precedence: escodegen.Precedence.Primary\n                },\n                type: NodeType.Literal,\n                value: nodeValue\n            };\n\n        delete node.name;\n\n        Object.assign(node, literalNode);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-obfuscators/ObjectExpressionObfuscator.ts","import * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeWithBlockStatement } from '../types/TNodeWithBlockStatement';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../interfaces/IOptions';\n\nimport { NodeType } from '../enums/NodeType';\n\nimport { AbstractNodeObfuscator } from './AbstractNodeObfuscator';\nimport { IdentifierReplacer } from './replacers/IdentifierReplacer';\nimport { Node } from '../node/Node';\nimport { NodeUtils } from '../node/NodeUtils';\n\n/**\n * replaces:\n *     var variable = 1;\n *     variable++;\n *\n * on:\n *     var _0x12d45f = 1;\n *     _0x12d45f++;\n *\n */\nexport class VariableDeclarationObfuscator extends AbstractNodeObfuscator {\n    /**\n     * @type {IdentifierReplacer}\n     */\n    private identifierReplacer: IdentifierReplacer;\n\n    /**\n     * @param nodes\n     * @param options\n     */\n    constructor(nodes: Map <string, ICustomNode>, options: IOptions) {\n        super(nodes, options);\n\n        this.identifierReplacer = new IdentifierReplacer(this.nodes, this.options);\n    }\n\n    /**\n     * @param variableDeclarationNode\n     * @param parentNode\n     */\n    public obfuscateNode (variableDeclarationNode: ESTree.VariableDeclaration, parentNode: ESTree.Node): void {\n        const blockScopeOfVariableDeclarationNode: TNodeWithBlockStatement = NodeUtils\n            .getBlockScopeOfNode(variableDeclarationNode);\n\n        if (blockScopeOfVariableDeclarationNode.type === NodeType.Program) {\n            return;\n        }\n\n        const scopeNode: ESTree.Node = variableDeclarationNode.kind === 'var'\n            ? blockScopeOfVariableDeclarationNode\n            : parentNode;\n\n        this.storeVariableNames(variableDeclarationNode);\n        this.replaceVariableNames(scopeNode);\n    }\n\n    /**\n     * @param variableDeclarationNode\n     */\n    private storeVariableNames (variableDeclarationNode: ESTree.VariableDeclaration): void {\n        variableDeclarationNode.declarations\n            .forEach((declarationNode: ESTree.VariableDeclarator) => {\n                if (Node.isIdentifierNode(declarationNode.id)) {\n                    this.identifierReplacer.storeNames(declarationNode.id.name);\n                }\n            });\n    }\n\n    /**\n     * @param scopeNode\n     */\n    private replaceVariableNames (scopeNode: ESTree.Node): void {\n        estraverse.replace(scopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (!node.obfuscated && Node.isReplaceableIdentifierNode(node, parentNode)) {\n                    node.name = this.identifierReplacer.replace(node.name);\n                }\n            }\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-obfuscators/VariableDeclarationObfuscator.ts","import { JSFuck } from '../../enums/JSFuck';\n\nimport { AbstractReplacer } from './AbstractReplacer';\n\nexport class BooleanLiteralReplacer extends AbstractReplacer {\n    /**\n     * @param nodeValue\n     * @returns {string}\n     */\n    public replace (nodeValue: boolean): string {\n        return nodeValue ? JSFuck.True : JSFuck.False;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-obfuscators/replacers/BooleanLiteralReplacer.ts","import {\n    ArrayUnique,\n    IsBoolean,\n    IsArray,\n    IsIn,\n    IsNumber,\n    IsString,\n    IsUrl,\n    Min,\n    Max,\n    ValidateIf,\n    validateSync,\n    ValidationError,\n    ValidatorOptions\n} from 'class-validator';\n\nimport { IObfuscatorOptions } from '../interfaces/IObfuscatorOptions';\nimport { IOptions } from '../interfaces/IOptions';\n\nimport { TSourceMapMode } from '../types/TSourceMapMode';\nimport { TStringArrayEncoding } from '../types/TStringArrayEncoding';\n\nimport { DEFAULT_PRESET } from '../preset-options/DefaultPreset';\n\nimport { OptionsNormalizer } from './OptionsNormalizer';\nimport { ValidationErrorsFormatter } from './ValidationErrorsFormatter';\n\nexport class Options implements IOptions {\n    /**\n     * @type {ValidatorOptions}\n     */\n    private static validatorOptions: ValidatorOptions = {\n        validationError: {\n            target: false\n        }\n    };\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly compact: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtection: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtectionInterval: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly disableConsoleOutput: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly domainLock: string[];\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly reservedNames: string[];\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly rotateStringArray: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    public readonly seed: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly selfDefending: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly sourceMap: boolean;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    @ValidateIf((options: IOptions) => Boolean(options.sourceMapBaseUrl))\n    @IsUrl({\n        require_protocol: true,\n        require_valid_protocol: true\n    })\n    public readonly sourceMapBaseUrl: string;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly sourceMapFileName: string;\n\n    /**\n     * @type {TSourceMapMode}\n     */\n    @IsIn(['inline', 'separate'])\n    public readonly sourceMapMode: TSourceMapMode;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly stringArray: boolean;\n\n    /**\n     * @type {TStringArrayEncoding}\n     */\n    @IsIn([true, false, 'base64', 'rc4'])\n    public readonly stringArrayEncoding: TStringArrayEncoding;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly stringArrayThreshold: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly unicodeEscapeSequence: boolean;\n\n    /**\n     * @param obfuscatorOptions\n     */\n    constructor (obfuscatorOptions: IObfuscatorOptions) {\n        Object.assign(this, DEFAULT_PRESET, obfuscatorOptions);\n\n        let errors: ValidationError[] = validateSync(this, Options.validatorOptions);\n\n        if (errors.length) {\n            throw new ReferenceError(`Validation failed. errors:\\n${ValidationErrorsFormatter.format(errors)}`);\n        }\n\n        Object.assign(this, OptionsNormalizer.normalizeOptions(this));\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/Options.ts","import { IObfuscatorOptions } from '../interfaces/IObfuscatorOptions';\nimport { IOptions } from '../interfaces/IOptions';\n\nimport { TOptionsNormalizerRule } from '../types/TOptionsNormalizerRule';\n\nimport { Utils } from '../Utils';\n\nexport class OptionsNormalizer {\n    /**\n     * @type {IObfuscatorOptions}\n     */\n    private static DISABLED_UNICODE_ARRAY_OPTIONS: IObfuscatorOptions = {\n        rotateStringArray: false,\n        stringArray: false,\n        stringArrayEncoding: false,\n        stringArrayThreshold: 0\n    };\n\n    /**\n     * @type {IObfuscatorOptions}\n     */\n    private static SELF_DEFENDING_OPTIONS: IObfuscatorOptions = {\n        compact: true,\n        selfDefending: true\n    };\n\n    /**\n     * @type {IObfuscatorOptions}\n     */\n    private static UNICODE_ARRAY_ENCODING_OPTIONS: IObfuscatorOptions = {\n        stringArrayEncoding: 'base64'\n    };\n\n    /**\n     * @type {TOptionsNormalizerRule[]}\n     */\n    private static normalizerRules: TOptionsNormalizerRule[] = [\n        OptionsNormalizer.domainLockRule,\n        OptionsNormalizer.selfDefendingRule,\n        OptionsNormalizer.sourceMapBaseUrlRule,\n        OptionsNormalizer.sourceMapFileNameRule,\n        OptionsNormalizer.stringArrayRule,\n        OptionsNormalizer.stringArrayEncodingRule,\n        OptionsNormalizer.stringArrayThresholdRule,\n    ];\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    public static normalizeOptions (options: IOptions): IOptions {\n        let normalizedOptions: IOptions = Object.assign({}, options);\n\n        for (const normalizerRule of OptionsNormalizer.normalizerRules) {\n            normalizedOptions = normalizerRule(normalizedOptions);\n        }\n\n        return normalizedOptions;\n    }\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    private static domainLockRule (options: IOptions): IOptions {\n        if (options.domainLock.length) {\n            let normalizedDomains: string[] = [];\n\n            for (const domain of options.domainLock) {\n                normalizedDomains.push(Utils.extractDomainFromUrl(domain));\n            }\n\n            Object.assign(options, {\n                domainLock: normalizedDomains\n            });\n        }\n\n        return options;\n    }\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    private static selfDefendingRule (options: IOptions): IOptions {\n        if (options.selfDefending) {\n            Object.assign(options, OptionsNormalizer.SELF_DEFENDING_OPTIONS);\n        }\n\n        return options;\n    }\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    private static sourceMapBaseUrlRule (options: IOptions): IOptions {\n        let sourceMapBaseUrl: string = options.sourceMapBaseUrl;\n\n        if (!options.sourceMapFileName) {\n            Object.assign(options, {\n                sourceMapBaseUrl: ''\n            });\n\n            return options;\n        }\n\n        if (sourceMapBaseUrl && !sourceMapBaseUrl.endsWith('/')) {\n            Object.assign(options, {\n                sourceMapBaseUrl: `${sourceMapBaseUrl}/`\n            });\n        }\n\n        return options;\n    }\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    private static sourceMapFileNameRule (options: IOptions): IOptions {\n        let sourceMapFileName: string = options.sourceMapFileName;\n\n        if (sourceMapFileName) {\n            sourceMapFileName = sourceMapFileName\n                .replace(/^\\/+/, '')\n                .split('.')[0];\n\n            Object.assign(options, {\n                sourceMapFileName: `${sourceMapFileName}.js.map`\n            });\n        }\n\n        return options;\n    }\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    private static stringArrayRule (options: IOptions): IOptions {\n        if (!options.stringArray) {\n            Object.assign(options, OptionsNormalizer.DISABLED_UNICODE_ARRAY_OPTIONS);\n        }\n\n        return options;\n    }\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    private static stringArrayEncodingRule (options: IOptions): IOptions {\n        if (options.stringArrayEncoding === true) {\n            Object.assign(options, OptionsNormalizer.UNICODE_ARRAY_ENCODING_OPTIONS);\n        }\n\n        return options;\n    }\n\n    /**\n     * @param options\n     * @returns {IOptions}\n     */\n    private static stringArrayThresholdRule (options: IOptions): IOptions {\n        if (options.stringArrayThreshold === 0) {\n            Object.assign(options, OptionsNormalizer.DISABLED_UNICODE_ARRAY_OPTIONS);\n        }\n\n        return options;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/OptionsNormalizer.ts","import { ValidationError } from 'class-validator';\n\nexport class ValidationErrorsFormatter {\n    /**\n     * @param validationErrors\n     * @returns {string}\n     */\n    public static format (validationErrors: ValidationError[]): string {\n        let errorsArray: string[] = [];\n\n        for (const error of validationErrors) {\n            errorsArray.push(ValidationErrorsFormatter.formatError(error));\n        }\n\n        return errorsArray.join('\\n');\n    }\n\n    /**\n     * @param validationError\n     * @returns {string}\n     */\n    private static formatError (validationError: ValidationError): string {\n        let errorString: string = `\\`${validationError.property}\\` errors:\\n`,\n            constraints: {[type: string]: string} = validationError.constraints;\n\n        for (const constraint in constraints) {\n            if (!constraints.hasOwnProperty(constraint)) {\n                continue;\n            }\n\n            errorString += `    - ${constraints[constraint]}\\n`;\n        }\n\n        return errorString;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/ValidationErrorsFormatter.ts","import * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TCalleeDataExtractor } from '../types/TCalleeDataExtractor';\n\nimport { ICalleeData } from '../interfaces/stack-trace-analyzer/ICalleeData';\nimport { IStackTraceAnalyzer } from '../interfaces/stack-trace-analyzer/IStackTraceAnalyzer';\nimport { IStackTraceData } from '../interfaces/stack-trace-analyzer/IStackTraceData';\n\nimport { NodeType } from '../enums/NodeType';\n\nimport { FunctionDeclarationCalleeDataExtractor } from './callee-data-extractors/FunctionDeclarationCalleeDataExtractor';\nimport { FunctionExpressionCalleeDataExtractor } from './callee-data-extractors/FunctionExpressionCalleeDataExtractor';\nimport { ObjectExpressionCalleeDataExtractor } from './callee-data-extractors/ObjectExpressionCalleeDataExtractor';\n\nimport { Node } from '../node/Node';\nimport { NodeUtils } from '../node/NodeUtils';\n\n/**\n * This class generates a data with code stack trace functions calls\n *\n * For example:\n *\n * function Foo () {\n *     var baz = function () {\n *\n *     }\n *\n *     baz();\n * }\n *\n * foo();\n *\n * Will generate a structure like:\n *\n * [\n *      {\n *          callee: FOO_FUNCTION_NODE\n *          name: 'Foo',\n *          trace: [\n *              {\n *                  callee: BAZ_FUNCTION_NODE,\n *                  name: 'baz,\n *                  trace: []\n *              }\n *          ]\n *      }\n * ]\n */\nexport class StackTraceAnalyzer implements IStackTraceAnalyzer {\n    /**\n     * @type {number}\n     */\n    private static limitThresholdActivationLength: number = 25;\n\n    /**\n     * @type {number}\n     */\n    private static limitThreshold: number = 0.002;\n\n    /**\n     * @type {ESTree.Node[]}\n     */\n    private blockScopeBody: ESTree.Node[];\n\n    /**\n     * @type {Map<string, TCalleeDataExtractor>}\n     */\n    private calleeDataExtractors: Map <string, TCalleeDataExtractor> = new Map <string, TCalleeDataExtractor> ([\n        [NodeType.FunctionDeclaration, FunctionDeclarationCalleeDataExtractor],\n        [NodeType.FunctionExpression, FunctionExpressionCalleeDataExtractor],\n        [NodeType.ObjectExpression, ObjectExpressionCalleeDataExtractor]\n    ]);\n\n    /**\n     * @param blockScopeBody\n     */\n    constructor (blockScopeBody: ESTree.Node[]) {\n        this.blockScopeBody = blockScopeBody;\n    }\n\n    /**\n     * @param blockScopeBodyLength\n     * @returns {number}\n     */\n    public static getLimitIndex (blockScopeBodyLength: number): number {\n        const lastIndex: number = blockScopeBodyLength - 1;\n        const limitThresholdActivationIndex: number = StackTraceAnalyzer.limitThresholdActivationLength - 1;\n\n        let limitIndex: number = lastIndex;\n\n        if (lastIndex > limitThresholdActivationIndex) {\n            limitIndex = Math.round(\n                limitThresholdActivationIndex + (lastIndex * StackTraceAnalyzer.limitThreshold)\n            );\n\n            if (limitIndex > lastIndex) {\n                limitIndex = lastIndex;\n            }\n        }\n\n        return limitIndex;\n    }\n\n    /**\n     * @returns {IStackTraceData[]}\n     */\n    public analyze (): IStackTraceData[] {\n        return this.analyzeRecursive(this.blockScopeBody);\n    }\n\n    /**\n     * @param blockScopeBody\n     * @returns {IStackTraceData[]}\n     */\n    private analyzeRecursive (blockScopeBody: ESTree.Node[]): IStackTraceData[] {\n        const limitIndex: number = StackTraceAnalyzer.getLimitIndex(blockScopeBody.length);\n        const stackTraceData: IStackTraceData[] = [];\n\n        for (\n            let index: number = 0, blockScopeBodyLength: number = blockScopeBody.length;\n            index < blockScopeBodyLength;\n            index++\n        ) {\n            let rootNode: ESTree.Node = blockScopeBody[index];\n\n            if (index > limitIndex) {\n                break;\n            }\n\n            estraverse.traverse(rootNode, {\n                enter: (node: ESTree.Node): any => {\n                    if (!Node.isCallExpressionNode(node) || rootNode.parentNode !== NodeUtils.getBlockScopeOfNode(node)) {\n                        return;\n                    }\n\n                    this.calleeDataExtractors.forEach((calleeDataExtractor: TCalleeDataExtractor) => {\n                        const calleeData: ICalleeData|null = new calleeDataExtractor(\n                            blockScopeBody,\n                            node.callee\n                        ).extract();\n\n                        if (!calleeData) {\n                            return;\n                        }\n\n                        stackTraceData.push(Object.assign({}, calleeData, {\n                            stackTrace: this.analyzeRecursive(calleeData.callee.body)\n                        }));\n                    });\n                }\n            });\n        }\n\n        return stackTraceData;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/stack-trace-analyzer/StackTraceAnalyzer.ts","import * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../interfaces/stack-trace-analyzer/ICalleeData';\nimport { ICalleeDataExtractor } from '../../interfaces/stack-trace-analyzer/ICalleeDataExtractor';\n\nimport { Node } from '../../node/Node';\nimport { NodeUtils } from '../../node/NodeUtils';\n\nexport class FunctionDeclarationCalleeDataExtractor implements ICalleeDataExtractor {\n    /**\n     * @type {ESTree.Node[]}\n     */\n    private blockScopeBody: ESTree.Node[];\n\n    /**\n     * @type {ESTree.Identifier}\n     */\n    private callee: ESTree.Identifier;\n\n    /**\n     * @param blockScopeBody\n     * @param callee\n     */\n    constructor (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier) {\n        this.blockScopeBody = blockScopeBody;\n        this.callee = callee;\n    }\n\n    /**\n     * @returns {ICalleeData|null}\n     */\n    public extract (): ICalleeData|null {\n        let calleeBlockStatement: ESTree.BlockStatement|null = null;\n\n        if (Node.isIdentifierNode(this.callee)) {\n            calleeBlockStatement = this.getCalleeBlockStatement(\n                NodeUtils.getBlockScopeOfNode(this.blockScopeBody[0]),\n                this.callee.name\n            );\n        }\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: this.callee.name\n        };\n    }\n\n    /**\n     * @param node\n     * @param name\n     * @returns {ESTree.BlockStatement|null}\n     */\n    private getCalleeBlockStatement (node: ESTree.Node, name: string): ESTree.BlockStatement|null {\n        let calleeBlockStatement: ESTree.BlockStatement|null = null;\n\n        estraverse.traverse(node, {\n            enter: (node: ESTree.Node): any => {\n                if (Node.isFunctionDeclarationNode(node) && node.id.name === name) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor.ts","import * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../interfaces/stack-trace-analyzer/ICalleeData';\nimport { ICalleeDataExtractor } from '../../interfaces/stack-trace-analyzer/ICalleeDataExtractor';\n\nimport { Node } from '../../node/Node';\nimport { NodeUtils } from '../../node/NodeUtils';\n\nexport class FunctionExpressionCalleeDataExtractor implements ICalleeDataExtractor {\n    /**\n     * @type {ESTree.Node[]}\n     */\n    private blockScopeBody: ESTree.Node[];\n\n    /**\n     * @type {ESTree.Identifier}\n     */\n    private callee: ESTree.Identifier;\n\n    /**\n     * @param blockScopeBody\n     * @param callee\n     */\n    constructor (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier) {\n        this.blockScopeBody = blockScopeBody;\n        this.callee = callee;\n    }\n\n    /**\n     * @returns {ICalleeData|null}\n     */\n    public extract (): ICalleeData|null {\n        let calleeBlockStatement: ESTree.BlockStatement|null = null;\n\n        if (Node.isIdentifierNode(this.callee)) {\n            calleeBlockStatement = this.getCalleeBlockStatement(\n                NodeUtils.getBlockScopeOfNode(this.blockScopeBody[0]),\n                this.callee.name\n            );\n        }\n\n        if (Node.isFunctionExpressionNode(this.callee)) {\n            calleeBlockStatement = this.callee.body;\n        }\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: this.callee.name || null\n        };\n    }\n\n    /**\n     * @param node\n     * @param name\n     * @returns {ESTree.BlockStatement|null}\n     */\n    private getCalleeBlockStatement (node: ESTree.Node, name: string): ESTree.BlockStatement|null {\n        let calleeBlockStatement: ESTree.BlockStatement|null = null;\n\n        estraverse.traverse(node, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (\n                    Node.isFunctionExpressionNode(node) &&\n                    Node.isVariableDeclaratorNode(parentNode) &&\n                    Node.isIdentifierNode(parentNode.id) &&\n                    parentNode.id.name === name\n                ) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor.ts","import * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TObjectMembersCallsChain } from '../../types/TObjectMembersCallsChain';\n\nimport { ICalleeData } from '../../interfaces/stack-trace-analyzer/ICalleeData';\nimport { ICalleeDataExtractor } from '../../interfaces/stack-trace-analyzer/ICalleeDataExtractor';\n\nimport { Node } from '../../node/Node';\nimport { NodeUtils } from '../../node/NodeUtils';\n\nexport class ObjectExpressionCalleeDataExtractor implements ICalleeDataExtractor {\n    /**\n     * @type {ESTree.Node[]}\n     */\n    private blockScopeBody: ESTree.Node[];\n\n    /**\n     * @type {ESTree.MemberExpression}\n     */\n    private callee: ESTree.MemberExpression;\n\n    /**\n     * @param blockScopeBody\n     * @param callee\n     */\n    constructor (blockScopeBody: ESTree.Node[], callee: ESTree.MemberExpression) {\n        this.blockScopeBody = blockScopeBody;\n        this.callee = callee;\n    }\n\n    /**\n     * @returns {ICalleeData|null}\n     */\n    public extract (): ICalleeData|null {\n        let calleeBlockStatement: ESTree.BlockStatement|null = null,\n            functionExpressionName: string|number|null = null;\n\n        if (Node.isMemberExpressionNode(this.callee)) {\n            const objectMembersCallsChain: TObjectMembersCallsChain = this.createObjectMembersCallsChain(\n                [],\n                this.callee\n            );\n\n            if (!objectMembersCallsChain.length) {\n                return null;\n            }\n\n            functionExpressionName = objectMembersCallsChain[objectMembersCallsChain.length - 1];\n            calleeBlockStatement = this.getCalleeBlockStatement(\n                NodeUtils.getBlockScopeOfNode(this.blockScopeBody[0]),\n                objectMembersCallsChain\n            );\n        }\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: functionExpressionName\n        };\n    }\n\n    /**\n     * Creates array with MemberExpression calls chain.\n     *\n     * Example: object.foo.bar(); // ['object', 'foo', 'bar']\n     *\n     * @param currentChain\n     * @param memberExpression\n     * @returns {TObjectMembersCallsChain}\n     */\n    private createObjectMembersCallsChain (\n        currentChain: TObjectMembersCallsChain,\n        memberExpression: ESTree.MemberExpression\n    ): TObjectMembersCallsChain {\n        // first step: processing memberExpression `property` property\n        if (Node.isIdentifierNode(memberExpression.property) && memberExpression.computed === false) {\n            currentChain.unshift(memberExpression.property.name);\n        } else if (\n            Node.isLiteralNode(memberExpression.property) &&\n            (\n                typeof memberExpression.property.value === 'string' ||\n                typeof memberExpression.property.value === 'number'\n            )\n        ) {\n            currentChain.unshift(memberExpression.property.value);\n        } else {\n            return currentChain;\n        }\n\n        // second step: processing memberExpression `object` property\n        if (Node.isMemberExpressionNode(memberExpression.object)) {\n            return this.createObjectMembersCallsChain(currentChain, memberExpression.object);\n        } else if (Node.isIdentifierNode(memberExpression.object)) {\n            currentChain.unshift(memberExpression.object.name);\n        }\n\n        return currentChain;\n    }\n\n    /**\n     * @param node\n     * @param objectMembersCallsChain\n     * @returns {ESTree.BlockStatement|null}\n     */\n    private getCalleeBlockStatement (\n        node: ESTree.Node,\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement|null {\n        const objectName: string|number|undefined = objectMembersCallsChain.shift();\n\n        if (!objectName) {\n            return null;\n        }\n\n        let calleeBlockStatement: ESTree.BlockStatement|null = null;\n\n        estraverse.traverse(node, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node): any => {\n                if (\n                    Node.isVariableDeclaratorNode(node) &&\n                    Node.isIdentifierNode(node.id) &&\n                    node.init &&\n                    Node.isObjectExpressionNode(node.init) &&\n                    node.id.name === objectName\n                ) {\n                    calleeBlockStatement = this.findCalleeBlockStatement(node.init.properties, objectMembersCallsChain);\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n\n    /**\n     * @param objectExpressionProperties\n     * @param objectMembersCallsChain\n     * @returns {ESTree.BlockStatement|null}\n     */\n    private findCalleeBlockStatement (\n        objectExpressionProperties: ESTree.Property[],\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement|null {\n        const nextItemInCallsChain: string|number|undefined = objectMembersCallsChain.shift();\n\n        if (!nextItemInCallsChain) {\n            return null;\n        }\n\n        for (const propertyNode of objectExpressionProperties) {\n            const isTargetPropertyNodeWithIdentifierKey: boolean =\n                Node.isIdentifierNode(propertyNode.key) && propertyNode.key.name === nextItemInCallsChain;\n            const isTargetPropertyNodeWithLiteralKey: boolean =\n                Node.isLiteralNode(propertyNode.key) &&\n                Boolean(propertyNode.key.value) &&\n                propertyNode.key.value === nextItemInCallsChain;\n\n            if (!isTargetPropertyNodeWithIdentifierKey && !isTargetPropertyNodeWithLiteralKey) {\n                continue;\n            }\n\n            if (Node.isObjectExpressionNode(propertyNode.value)) {\n                return this.findCalleeBlockStatement(propertyNode.value.properties, objectMembersCallsChain);\n            }\n\n            if (Node.isFunctionExpressionNode(propertyNode.value)) {\n                return propertyNode.value.body;\n            }\n        }\n\n        return null;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor.ts","/**\n * @returns {string}\n */\nexport function AtobTemplate (): string {\n    return `\n        (function () {\n            var getGlobal = Function('return (function () ' + '{}.constructor(\"return this\")()' + ');');\n\n            var object = getGlobal();\n            var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n            object.atob || (\n                object.atob = function(input) {\n                    var str = String(input).replace(/=+$/, '');\n                    for (\n                        var bc = 0, bs, buffer, idx = 0, output = '';\n                        buffer = str.charAt(idx++);\n                        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n                            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n                    ) {\n                        buffer = chars.indexOf(buffer);\n                    }\n                return output;\n            });\n        })();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/custom-nodes/AtobTemplate.ts","/**\n * @returns {string}\n */\nexport function Rc4Template (): string {\n    return `\n        var rc4 = function (str, key) {\n            var s = [], j = 0, x, res = '', newStr = '';\n           \n            str = atob(str);\n                \n            for (var k = 0, length = str.length; k < length; k++) {\n                newStr += '%' + ('00' + str.charCodeAt(k).toString(16)).slice(-2);\n            }\n        \n            str = decodeURIComponent(newStr);\n                    \t        \n\t        for (var i = 0; i < 256; i++) {\n                s[i] = i;\n            }\n \n            for (i = 0; i < 256; i++) {\n                j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n            }\n            \n            i = 0;\n            j = 0;\n            \n            for (var y = 0; y < str.length; y++) {\n                i = (i + 1) % 256;\n                j = (j + s[i]) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n                res += String.fromCharCode(str.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n            }\n                      \n            return res;\n        }\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/custom-nodes/Rc4Template.ts","/**\n * @returns {string}\n */\nexport function SingleNodeCallControllerTemplate (): string {\n    return `\n        var {singleNodeCallControllerFunctionName} = (function(){\n            var firstCall = true;\n            \n            return function (context, fn){\t\n                var rfn = firstCall ? function(){\n                    if(fn){\n                        var res = fn.apply(context, arguments);\n                        fn = null;\n                        return res;\n                    }\n                } : function(){}\n                \n                firstCall = false;\n                \n                return rfn;\n            }\n        })();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/custom-nodes/SingleNodeCallControllerTemplate.ts","/**\n * @returns {string}\n */\nexport function ConsoleOutputDisableExpressionTemplate (): string {\n    return `\n        var {consoleLogDisableFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var getGlobal = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');');\n            \n            var func = function () {};\n            var that = getGlobal();\n            \n            if (!that.console) {\n                that.console = (function (func){ \n                    var c = {}; \n                    \n                    c.log = func;\n                    c.warn = func; \n                    c.debug = func;\n                    c.info = func;\n                    c.error = func;\n                    c.exception = func;\n                    c.trace = func;\n                    \n                    return c; \n                })(func);\n            } else {\n                that.console.log = func;\n                that.console.warn = func; \n                that.console.debug = func;\n                that.console.info = func;\n                that.console.error = func;\n                that.console.exception = func;\n                that.console.trace = func;\n            }\n        });\n        \n        {consoleLogDisableFunctionName}();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/custom-nodes/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate.ts","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionCallTemplate (): string {\n    return `{debugProtectionFunctionName}();`;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/custom-nodes/debug-protection-nodes/debug-protection-function-call-node/DebufProtectionFunctionCallTemplate.ts","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionIntervalTemplate (): string {\n    return `\n        setInterval(function () {\n            {debugProtectionFunctionName}();\n        }, 4000);\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/custom-nodes/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate.ts","import { Utils } from '../../../../Utils';\n\n/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionTemplate (): string {\n    return `\n        var {debugProtectionFunctionName} = function () {\n            function debuggerProtection (counter) {\n                if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                    (function () {}.constructor(${Utils.stringToJSFuck('debugger')})());\n                } else {\n                    (function () {}.constructor(${Utils.stringToJSFuck('debugger')})());\n                }\n                \n                debuggerProtection(++counter);\n            }\n            \n            try {\n                debuggerProtection(0);\n            } catch (y) {}\n        };\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/custom-nodes/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate.ts","/**\n * @returns {string}\n */\nexport function DomainLockNodeTemplate (): string {\n    return `\n        var {domainLockFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var getGlobal = Function('return (function () ' + '{}.constructor(\"return this\")()' + ');');\n\n            var func = function () { \n                return {\n                    key: 'item',\n                    value: 'attribute',\n                    getAttribute: function () {\n                        getGlobal()['eval']('while(true){}')();\n                    }()\n                };\n            };\n                        \n            var regExp = new RegExp(\"[{diff}]\", \"g\");\n            var domains = \"{domains}\".replace(regExp, \"\").split(\";\");\n            var eval = [][\"forEach\"][\"constructor\"];\n            var windowObject = eval(\"return this\")();\n            var document;\n            var domain;\n                        \n            for (var d in windowObject) {\n                if (d.length == 8 && d.charCodeAt(7) == 116 && d.charCodeAt(5) == 101 && d.charCodeAt(3) == 117 && d.charCodeAt(0) == 100) {\n                    document = d;\n                \n                    break;\n                }\n            }\n\n            for (var d1 in windowObject[document]) {\n                if (d1.length == 6 && d1.charCodeAt(5) == 110 && d1.charCodeAt(0) == 100) {\n                    domain = d1;\n                    \n                    break;\n                }\n            }\n            \n            if ((!document && !domain) || (!windowObject[document] && !windowObject[document][domain])) {\n                return;\n            }\n            \n            var currentDomain = windowObject[document][domain];\n\n            var ok = false;\n                        \n            for (var i = 0; i < domains.length; i++) {\n                var domain = domains[i];\n                var position = currentDomain.length - domain.length;\n                var lastIndex = currentDomain.indexOf(domain, position);\n                var endsWith = lastIndex !== -1 && lastIndex === position;\n                \n                if (endsWith) {\n                    if (currentDomain.length == domain.length || domain.indexOf(\".\") === 0) {\n                        ok = true;\n                    }\n                    \n                    break;\n                }\n            }\n               \n            if (!ok) {\n                data;\n            } else {\n                return;\n            }\n            \n            func();\n        });\n\n        {domainLockFunctionName}();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/custom-nodes/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate.ts","import { Utils } from '../../../../Utils';\n\n/**\n * SelfDefendingTemplate. Enters code in infinity loop.\n * Notice, that second and third call to recursiveFunc1('indexOf') has cyrillic `е` character instead latin\n *\n * @returns {string}\n */\nexport function SelfDefendingTemplate (): string {\n    return `\n        var {selfDefendingFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var func1 = function(){return 'dev';},\n                func2 = function () {\n                    return 'window';\n                };\n                \n            var test1 = function () {\n                var regExp = new RegExp('${Utils.stringToUnicodeEscapeSequence(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`)}');\n                \n                return !regExp.test(func1.toString());\n            };\n            \n            var test2 = function () {\n                var regExp = new RegExp('${Utils.stringToUnicodeEscapeSequence(`(\\\\\\\\[x|u](\\\\w){2,4})+`)}');\n                \n                return regExp.test(func2.toString());\n            };\n            \n            var recursiveFunc1 = function (string) {\n                var i = ~-1 >> 1 + 255 % 0;\n                                \n                if (string.indexOf('i' === i)) {\n                    recursiveFunc2(string)\n                }\n            };\n            \n            var recursiveFunc2 = function (string) {\n                var i = ~-4 >> 1 + 255 % 0;\n                \n                if (string.indexOf((true+\"\")[3]) !== i) {\n                    recursiveFunc1(string)\n                }\n            };\n            \n            if (!test1()) {\n                if (!test2()) {\n                    recursiveFunc1('indеxOf');\n                } else {\n                    recursiveFunc1('indexOf');\n                }\n            } else {\n                recursiveFunc1('indеxOf');\n            }\n        })\n        \n        {selfDefendingFunctionName}();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/custom-nodes/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate.ts","import { Utils } from '../../../../Utils';\n\n/**\n * @returns {string}\n */\nexport function SelfDefendingTemplate (): string {\n    return `\n        var StatesClass = function (rc4Bytes) {\n            this.rc4Bytes = rc4Bytes;\n            this.states = [1, 0, 0];\n            this.newState = function(){return 'newState';};\n            this.firstState = '${Utils.stringToUnicodeEscapeSequence(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *`)}';\n            this.secondState = '${Utils.stringToUnicodeEscapeSequence(`['|\"].+['|\"];? *}`)}';\n        };\n        \n        StatesClass.prototype.checkState = function () {\n            var regExp = new RegExp(this.firstState + this.secondState);\n\n            return this.runState(regExp.test(this.newState.toString()) ? --this.states[1] : --this.states[0]);\n        };\n        \n        StatesClass.prototype.runState = function (stateResult) {\n            if (!Boolean(~stateResult)) {\n                return stateResult;\n            }\n            \n            return this.getState(this.rc4Bytes);\n        };\n\n        StatesClass.prototype.getState = function (rc4Bytes) {\n            for (var i = 0, len = this.states.length; i < len; i++) {\n                this.states.push(Math.round(Math.random()));\n                len = this.states.length;\n            }\n            \n            return rc4Bytes(this.states[0]);\n        };\n\n        new StatesClass({stringArrayCallsWrapperName}).checkState();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate.ts","/**\n * @returns {string}\n */\nexport function StringArrayBase64DecodeNodeTemplate (): string {\n    return `      \n        if (!{stringArrayCallsWrapperName}.atobPolyfillAppended) {\n            {atobPolyfill}\n            \n            {stringArrayCallsWrapperName}.atobPolyfillAppended = true;\n        }\n        \n        if (!{stringArrayCallsWrapperName}.base64DecodeUnicode) {                \n            {stringArrayCallsWrapperName}.base64DecodeUnicode = function (str) {\n                var string = atob(str);\n                var newStringChars = [];\n                \n                for (var i = 0, length = string.length; i < length; i++) {\n                    newStringChars += '%' + ('00' + string.charCodeAt(i).toString(16)).slice(-2);\n                }\n                \n                return decodeURIComponent(newStringChars);\n            };\n        }\n        \n        if (!{stringArrayCallsWrapperName}.data) {\n            {stringArrayCallsWrapperName}.data = {};\n        }\n                        \n        if (!{stringArrayCallsWrapperName}.data[index]) {\n            {selfDefendingCode}\n            \n            value = {stringArrayCallsWrapperName}.base64DecodeUnicode(value);\n            {stringArrayCallsWrapperName}.data[index] = value;\n        } else {\n            value = {stringArrayCallsWrapperName}.data[index];\n        }  \n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate.ts","/**\n * @returns {string}\n */\nexport function StringArrayCallsWrapperTemplate (): string {\n    return `\n        var {stringArrayCallsWrapperName} = function (index, key) {\n            var index = parseInt(index, 0x10);\n            var value = {stringArrayName}[index];\n            \n            {decodeNodeTemplate}\n        \n            return value;\n        };\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate.ts","/**\n * @returns {string}\n */\nexport function StringArrayRc4DecodeNodeTemplate (): string {\n    return `\n        if (!{stringArrayCallsWrapperName}.atobPolyfillAppended) {            \n            {atobPolyfill}\n            \n            {stringArrayCallsWrapperName}.atobPolyfillAppended = true;\n        }\n        \n        if (!{stringArrayCallsWrapperName}.rc4) {            \n            {rc4Polyfill}\n            \n            {stringArrayCallsWrapperName}.rc4 = rc4;\n        }\n                        \n        if (!{stringArrayCallsWrapperName}.data) {\n            {stringArrayCallsWrapperName}.data = {};\n        }\n\n        if ({stringArrayCallsWrapperName}.data[index] === undefined) {\n            if (!{stringArrayCallsWrapperName}.once) {\n                {selfDefendingCode}\n                \n                {stringArrayCallsWrapperName}.once = true;\n            }\n            \n            value = {stringArrayCallsWrapperName}.rc4(value, key);\n            {stringArrayCallsWrapperName}.data[index] = value;\n        } else {\n            value = {stringArrayCallsWrapperName}.data[index];\n        }\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/custom-nodes/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate.ts","/**\n * @returns {string}\n */\nexport function StringArrayTemplate (): string {\n    return `\n        var {stringArrayName} = [{stringArray}];\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/custom-nodes/string-array-nodes/string-array-node/StringArrayTemplate.ts","import { Utils } from '../../../../Utils';\n\n/**\n * SelfDefendingTemplate. Enter code in infinity loop.\n *\n * @returns {string}\n */\nexport function SelfDefendingTemplate (): string {\n    return `\n        var selfDefendingFunc = function () {            \n            var object = {\n                data: {\n                    key: 'cookie',\n                    value: 'timeout'\n                },\n                setCookie: function (options, name, value, document) {\n                    document = document || {};\n                    \n                    var updatedCookie = name + \"=\" + value;\n\n                    var i = 0;\n                                                            \n                    for (var i = 0, len = options.length; i < len; i++) {                          \n                        var propName = options[i];\n                                     \n                        updatedCookie += \"; \" + propName;\n                        \n                        var propValue = options[propName];\n                        \n                        options.push(propValue);\n                        len = options.length;\n                                                                        \n                        if (propValue !== true) {\n                            updatedCookie += \"=\" + propValue;\n                        }\n                    }\n\n                    document['cookie'] = updatedCookie;\n                },\n                removeCookie: function(){return 'dev';},\n                getCookie: function (document, name) {    \n                    document = document || function (value) { return value };\n                    var matches = document(new RegExp(\n                        \"(?:^|; )\" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, '\\\\$1') + \"=([^;]*)\"\n                    ));\n                    \n                    var func = function (param1, param2) {\n                        param1(++param2);\n                    };\n                    \n                    func({whileFunctionName}, {timesName});\n                                        \n                    return matches ? decodeURIComponent(matches[1]) : undefined;\n                }\n            };\n            \n            var test1 = function () {\n                var regExp = new RegExp('${Utils.stringToUnicodeEscapeSequence(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`)}');\n                \n                return regExp.test(object.removeCookie.toString());\n            };\n            \n            object['updateCookie'] = test1;\n            \n            var cookie = '';\n            var result = object['updateCookie']();\n                                    \n            if (!result) {\n                object['setCookie'](['*'], 'counter', 1);\n            } else if (result) {\n                cookie = object['getCookie'](null, 'counter');     \n            } else {\n                object['removeCookie']();\n            }\n        };\n        \n        selfDefendingFunc();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/custom-nodes/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate.ts","/**\n * @returns {string}\n */\nexport function StringArrayRotateFunctionTemplate (): string {\n    return `\n        (function (array, {timesName}) {\n            var {whileFunctionName} = function (times) {\n                while (--times) {\n                    array['push'](array['shift']());\n                }\n            };\n            \n            {code}\n        })({stringArrayName}, 0x{stringArrayRotateValue});\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/custom-nodes/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate.ts","module.exports = require(\"class-validator\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"class-validator\"\n// module id = 83\n// module chunks = 0","module.exports = require(\"commander\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"commander\"\n// module id = 84\n// module chunks = 0","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 85\n// module chunks = 0","module.exports = require(\"mkdirp\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"mkdirp\"\n// module id = 86\n// module chunks = 0","\"use strict\";\n\nimport { JavaScriptObfuscator } from './src/JavaScriptObfuscator';\n\nif (!(<any>global)._babelPolyfill) {\n    require('babel-polyfill');\n}\n\nmodule.exports = JavaScriptObfuscator;\n\n\n\n// WEBPACK FOOTER //\n// ./index.ts"],"sourceRoot":""}